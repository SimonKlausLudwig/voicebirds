{"version":3,"sources":["webpack:///./test_project/node_modules/slate/dist/index.es.js"],"names":["_createForOfIteratorHelper","o","Symbol","iterator","Array","isArray","minLen","_arrayLikeToArray","n","Object","prototype","toString","call","slice","constructor","name","from","test","_unsupportedIterableToArray","i","F","s","length","done","value","e","_e","f","TypeError","it","err","normalCompletion","didErr","step","next","_e2","arr","len","arr2","_defineProperty","obj","key","defineProperty","enumerable","configurable","writable","_objectWithoutProperties","source","excluded","target","sourceKeys","keys","indexOf","_objectWithoutPropertiesLoose","getOwnPropertySymbols","sourceSymbolKeys","propertyIsEnumerable","DIRTY_PATHS","WeakMap","FLUSHING","NORMALIZING","PATH_REFS","POINT_REFS","RANGE_REFS","SPACE","PUNCTUATION","CHAMELEON","getCharacterDistance","text","offset","prev","charCode","charCodeAt","isSurrogate","modifier","isModifier","isBMPEmoji","isVariationSelector","getWordDistance","_char","started","charAt","l","rest","isWordCharacter","_char2","remaining","code","ownKeys","object","enumerableOnly","symbols","filter","sym","getOwnPropertyDescriptor","push","apply","_objectSpread","arguments","forEach","getOwnPropertyDescriptors","defineProperties","Editor","above","editor","options","undefined","_options$voids","voids","_options$mode","mode","_options$at","at","selection","match","_step","path","reverse","_iterator","levels","_step$value","p","Text","isText","Path","equals","addMark","after","_step2","anchor","point","edge","focus","end","range","_options$distance","distance","d","_iterator2","positions","before","_step3","start","_options$distance2","_iterator3","deleteBackward","_options$unit","unit","deleteForward","_options$unit2","deleteFragment","edges","first","node","fragment","Node","hasBlocks","element","children","some","isBlock","hasInlines","isInline","hasTexts","every","insertBreak","insertFragment","insertNode","insertText","Element","isElement","isEditor","isVoid","normalizeNode","onChange","removeMark","marks","Range","isRange","isNodeList","Operation","isOperationList","operations","isEnd","Point","isEdge","isStart","isEmpty","isNormalizing","get","last","leaf","mark","_options$at2","_options$reverse","_options$voids2","_iterator4","_step4","_step4$value","_args","wrap","_context","abrupt","t0","finish","delegateYield","stop","isExpanded","_Editor$nodes","nodes","_Editor$leaf","previous","block","_prev2","prevNode","prevPath","blockPath","isAncestor","_options$mode2","_options$voids3","_options$at3","_Editor$last","_Editor$last2","_Editor$last3","_Editor$last4","to","span","isPath","Error","_Editor$parent","parent","_Editor$parent2","includes","_Editor$nodes3","_Editor$nodes4","_options$at4","_options$mode3","_options$universal","universal","_options$reverse2","_options$voids4","iterable","matches","hit","_iterator5","_step5","_step5$value","isLower","emit","_args2","_context2","Span","isSpan","pass","_ref","compare","normalize","_options$force","force","getDirtyPaths","allPaths","_ref2","set","withoutNormalizing","max","m","concat","pop","entry","parentPath","depth","_Node$first","_Node$first2","firstPath","_Node$last","_Node$last2","lastPath","common","isPoint","pathRef","_options$affinity","affinity","ref","current","unref","pathRefs","refs","add","Set","_options$edge","_Node$last3","_Node$last4","_Node$first3","_Node$first4","_Range$edges","_Range$edges2","pointRef","_options$affinity2","pointRefs","_options$at5","_options$unit3","_options$reverse3","reverse$1","_Range$edges3","_Range$edges4","string","available","isNewBlock","advance","_iterator6","_step6","_step6$value","isFirst","_args3","_context3","_options$mode4","_options$voids5","_options$at6","_Editor$first","_Editor$first2","_Editor$first3","_Editor$first4","_Editor$parent3","_Editor$parent4","_Editor$nodes5","_Editor$nodes6","rangeRef","_options$affinity3","rangeRefs","_step7","_Range$edges5","_Range$edges6","_iterator7","_step7$value","t","transform","op","type","index","splice","_step8","_iterator8","points","_step8$value","_path","_node2","_step9","_iterator9","_step9$value","_point","_path2","_node3","_parent","_index","_prev$children","_step10","_iterator10","_step10$value","_point2","_path3","newPath","_node4","_parent2","_index2","truePath","newParent","newIndex","_step11","_iterator11","_step11$value","_point3","_path4","_index3","_step12","_iterator12","_step12$value","_point4","_key4","result","_step13","_prev","_iterator13","texts","_step13$value","_path5","_offset","_text2","_node5","_before","_after","_step14","_iterator14","_step14$value","_point5","_path6","newProperties","_node6","_key6","_newProperties","JSON","stringify","assign","_path7","position","properties","newNode","_node7","_parent4","_index4","_before2","_after2","_before3","_after3","_step15","_iterator15","_step15$value","_point6","unhangRange","_options$voids6","_Range$edges7","_Range$edges8","isCollapsed","_step16","endBlock","skip","_iterator16","_step16$value","isBefore","fn","isElementList","props","ancestor","root","ancestors","_iterator17","_step17","_args4","_context4","child","c","_options$reverse4","childPath","_args5","_context5","another","descendant","descendants","_iterator18","_step18","_step18$value","_args6","_context6","elements","_iterator19","_step19","_step19$value","_args7","_context7","r","_step20","_Range$edges9","_Range$edges10","_iterator20","_leaf","has","isNode","_iterator21","_step21","_args8","_context8","_options$reverse5","_options$from","visited","nextIndex","_newPath","_args9","_context9","isAfter","map","join","_iterator22","_step22","_step22$value","_args10","_context10","ownKeys$1","_objectSpread$1","isNodeOperation","isOperation","endsWith","isSelectionOperation","isTextOperation","inverse","_properties","_options$reverse6","paths","av","min","Math","endsAfter","as","bs","bv","endsAt","endsBefore","isChild","isCommon","isDescendant","isParent","isSibling","_options$reverse7","list","relative","operation","_options$affinity4","_op","_op2","_op3","_position","_op4","onp","copy","PathRef","ownKeys$2","_objectSpread$2","_options$affinity5","PointRef","ownKeys$3","_options$reverse8","isBackward","_Range$edges11","_Range$edges13","_Range$edges14","rs","re","_Range$edges15","_Range$edges16","ts","te","_Range$edges17","_Range$edges18","isAfterStart","isBeforeEnd","intersection","_Range$edges19","_Range$edges20","s1","e1","_Range$edges21","_Range$edges22","s2","e2","_objectSpread$3","isForward","_context11","_Range$edges23","affinityAnchor","affinityFocus","_options$affinity6","RangeRef","ownKeys$4","_objectSpread$4","_options$loose","loose","_key","isTextList","decorations","_decorations","_step23","leaves","_iterator23","_step24","dec","_Range$edges25","_Range$edges26","_iterator24","middle","off","_off","ownKeys$5","_objectSpread$5","ownKeys$6","_objectSpread$6","NodeTransforms","insertNodes","_options$hanging","hanging","_options$voids7","_options$mode5","select","_nodes","_Range$edges27","Transforms","_Editor$nodes7","_matchPath","isAtEnd","splitNodes","_step33","_iterator33","_node","liftNodes","_options$at7","_options$mode6","_options$voids8","matchPath","_i","_pathRefs","parentNodeEntry","_parentNodeEntry","toPath","moveNodes","removeNodes","_toPath","splitPath","_toPath2","mergeNodes","_options$at8","_options$hanging2","_options$voids9","_options$mode7","_Editor$parent5","_Range$edges29","_Editor$nodes9","_current","_prev3","commonPath","isPreviousSibling","emptyAncestor","emptyRef","_options$at9","_options$mode8","_options$voids10","toRef","targets","_i2","_pathRefs2","_ref3","_options$hanging3","_options$voids11","_options$mode9","_options$at10","depths","_i3","_pathRefs3","_ref4","_Editor$node","setNodes","_options$at11","_options$hanging4","_options$mode10","_options$split","split","_options$voids12","_Range$edges31","_Range$edges32","splitMode","_step34","_iterator34","_step34$value","k","_options$mode11","_options$voids13","_options$at12","_options$height","height","_options$always","always","deleteRange","_Editor$parent7","beforeRef","_Editor$nodes11","highest","voidMatch","_voidMatch","voidNode","voidPath","afterPath","_step35","afterRef","highestPath","lowestPath","_iterator35","_step35$value","unsetNodes","_step36","_iterator36","unwrapNodes","_options$mode12","_options$split2","_options$voids14","_options$at13","_loop","_Editor$node3","_i4","_pathRefs4","_ref5","wrapNodes","_options$mode13","_options$split3","_options$voids15","_options$at14","_Range$edges33","_Range$edges34","_i5","_roots","rootPath","a","commonNodeEntry","commonNode","wrapperPath","wrapper","_Range$edges35","_Editor$node5","ownKeys$7","ownKeys$8","_objectSpread$8","_step25","_iterator25","_step25$value","_step26","_iterator26","_step26$value","_prev$children2","_step27","_iterator27","_step27$value","_step28","_iterator28","_step28$value","_step29","_iterator29","_step29$value","_step30","_iterator30","_step30$value","_text","_step31","_iterator31","_step31$value","_step32","_iterator32","_step32$value","collapse","_options$edge2","_Range$edges37","_Range$edges38","_Range$edges39","_Range$edges40","deselect","move","_options$distance3","_options$unit4","_options$reverse9","_options$edge3","opts","setSelection","setPoint","_options$edge4","_objectSpread$7","oldProps","newProps","_options$reverse10","_options$unit5","_options$distance4","_options$voids16","_options$at15","_options$hanging5","furthestVoid","_Range$edges41","_Range$edges42","startBlock","isAcrossBlocks","isSingleText","startVoid","endVoid","_step37","_iterator37","_entry2","startRef","endRef","_Editor$leaf3","_i6","_pathRefs5","_Editor$leaf5","_options$hanging6","_options$voids17","_options$at16","_Range$edges43","inlineElementMatch","_inlinePath","_step38","blockMatch","isBlockStart","isBlockEnd","mergeStart","mergeEnd","_Node$first5","_Node$last5","matcher","_ref15","_iterator38","starts","middles","ends","starting","_i7","_matches2","_Editor$nodes13","inlineMatch","inlinePath","isInlineStart","isInlineEnd","middleRef","_end","_options$voids18","_options$at17","_at","ownKeys$9","_objectSpread$9","createEditor","_step39","_iterator39","_step40","_iterator40","_step41","_iterator41","_step42","dirtyPaths","oldDirtyPaths","newDirtyPaths","_iterator42","_step43","_iterator43","Promise","resolve","then","getFragment","inline","_entry3","shouldHaveInlines","_child","isLast","previousPath","_step44","oldAncestors","newAncestors","_iterator44","_step45","_iterator45","_ancestor","_p","_ancestors","_levels","nextPath"],"mappings":"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","file":"f4800e2f-6e3e8ded64bcfeee6f13.js","sourcesContent":["import \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport \"core-js/modules/es6.promise\";\nimport _defineProperty2 from \"/Users/simonludwig/projects/voicebirds/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.string.ends-with\";\nimport \"core-js/modules/es6.array.map\";\nimport \"core-js/modules/es6.object.assign\";\nimport _toConsumableArray from \"/Users/simonludwig/projects/voicebirds/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es6.set\";\nimport \"core-js/modules/es6.array.from\";\nimport \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.string.anchor\";\nimport _regeneratorRuntime from \"/Users/simonludwig/projects/voicebirds/node_modules/@babel/runtime/regenerator\";\nimport \"regenerator-runtime/runtime\";\nimport \"core-js/modules/es6.array.is-array\";\nimport \"core-js/modules/es6.array.some\";\nimport _slicedToArray from \"/Users/simonludwig/projects/voicebirds/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.object.define-properties\";\nimport \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/es6.array.for-each\";\nimport \"core-js/modules/es6.array.filter\";\nimport \"core-js/modules/es6.string.iterator\";\nimport \"core-js/modules/es6.weak-map\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/es6.array.index-of\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.to-string\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.object.define-property\";\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport isPlainObject from 'is-plain-object';\nimport { createDraft, finishDraft, isDraft, produce } from 'immer';\nimport { reverse } from 'esrever';\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nvar DIRTY_PATHS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n/**\r\n * Constants for string distance checking.\r\n */\n\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\nvar ZERO_WIDTH_JOINER = 0x200d;\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\n\nvar getCharacterDistance = function getCharacterDistance(text) {\n  var offset = 0; // prev types:\n  // SURR: surrogate pair\n  // MOD: modifier (technically also surrogate pair)\n  // ZWJ: zero width joiner\n  // VAR: variation selector\n  // BMP: sequenceable character from basic multilingual plane\n\n  var prev = null;\n  var charCode = text.charCodeAt(0);\n\n  while (charCode) {\n    if (isSurrogate(charCode)) {\n      var modifier = isModifier(charCode, text, offset); // Early returns are the heart of this function, where we decide if previous and current\n      // codepoints should form a single character (in terms of how many of them should selection\n      // jump over).\n\n      if (prev === 'SURR' || prev === 'BMP') {\n        break;\n      }\n\n      offset += 2;\n      prev = modifier ? 'MOD' : 'SURR';\n      charCode = text.charCodeAt(offset); // Absolutely fine to `continue` without any checks because if `charCode` is NaN (which\n      // is the case when out of `text` range), next `while` loop won\"t execute and we\"re done.\n\n      continue;\n    }\n\n    if (charCode === ZERO_WIDTH_JOINER) {\n      offset += 1;\n      prev = 'ZWJ';\n      charCode = text.charCodeAt(offset);\n      continue;\n    }\n\n    if (isBMPEmoji(charCode)) {\n      if (prev && prev !== 'ZWJ' && prev !== 'VAR') {\n        break;\n      }\n\n      offset += 1;\n      prev = 'BMP';\n      charCode = text.charCodeAt(offset);\n      continue;\n    }\n\n    if (isVariationSelector(charCode)) {\n      if (prev && prev !== 'ZWJ') {\n        break;\n      }\n\n      offset += 1;\n      prev = 'VAR';\n      charCode = text.charCodeAt(offset);\n      continue;\n    } // Modifier 'groups up' with what ever character is before that (even whitespace), need to\n    // look ahead.\n\n\n    if (prev === 'MOD') {\n      offset += 1;\n      break;\n    } // If while loop ever gets here, we're done (e.g latin chars).\n\n\n    break;\n  }\n\n  return offset || 1;\n};\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\n\nvar getWordDistance = function getWordDistance(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n\n  var _char;\n\n  while (_char = text.charAt(i)) {\n    var l = getCharacterDistance(_char);\n    _char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWordCharacter(_char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\n\nvar isWordCharacter = function isWordCharacter(_char2, remaining) {\n  if (SPACE.test(_char2)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(_char2)) {\n    var next = remaining.charAt(0);\n    var length = getCharacterDistance(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n\n    if (isWordCharacter(next, rest)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(_char2)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Determines if `code` is a surrogate\r\n */\n\n\nvar isSurrogate = function isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END;\n};\n/**\r\n * Does `code` form Modifier with next one.\r\n *\r\n * https://emojipedia.org/modifiers/\r\n */\n\n\nvar isModifier = function isModifier(code, text, offset) {\n  if (code === 0xd83c) {\n    var next = text.charCodeAt(offset + 1);\n    return next <= 0xdfff && next >= 0xdffb;\n  }\n\n  return false;\n};\n/**\r\n * Is `code` a Variation Selector.\r\n *\r\n * https://codepoints.net/variation_selectors\r\n */\n\n\nvar isVariationSelector = function isVariationSelector(code) {\n  return code <= 0xfe0f && code >= 0xfe00;\n};\n/**\r\n * Is `code` one of the BMP codes used in emoji sequences.\r\n *\r\n * https://emojipedia.org/emoji-zwj-sequences/\r\n */\n\n\nvar isBMPEmoji = function isBMPEmoji(code) {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return code === 0x2764 || // heart (❤)\n  code === 0x2642 || // male (♂)\n  code === 0x2640 || // female (♀)\n  code === 0x2620 || // scull (☠)\n  code === 0x2695 || // medical (⚕)\n  code === 0x2708 || // plane (✈️)\n  code === 0x25ef // large circle (◯)\n  ;\n};\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Editor = {\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\n  above: function above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$voids = options.voids,\n        voids = _options$voids === void 0 ? false : _options$voids,\n        _options$mode = options.mode,\n        mode = _options$mode === void 0 ? 'lowest' : _options$mode,\n        _options$at = options.at,\n        at = _options$at === void 0 ? editor.selection : _options$at,\n        match = options.match;\n\n    if (!at) {\n      return;\n    }\n\n    var path = Editor.path(editor, at);\n    var reverse = mode === 'lowest';\n\n    var _iterator = _createForOfIteratorHelper(Editor.levels(editor, {\n      at: path,\n      voids: voids,\n      match: match,\n      reverse: reverse\n    })),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var _step$value = _slicedToArray(_step.value, 2),\n            n = _step$value[0],\n            p = _step$value[1];\n\n        if (!Text.isText(n) && !Path.equals(path, p)) {\n          return [n, p];\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n  },\n\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\n  addMark: function addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after: function after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance = options.distance,\n        distance = _options$distance === void 0 ? 1 : _options$distance;\n    var d = 0;\n    var target;\n\n    var _iterator2 = _createForOfIteratorHelper(Editor.positions(editor, _objectSpread({}, options, {\n      at: range\n    }))),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var p = _step2.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before: function before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor: anchor,\n      focus: focus\n    };\n    var _options$distance2 = options.distance,\n        distance = _options$distance2 === void 0 ? 1 : _options$distance2;\n    var d = 0;\n    var target;\n\n    var _iterator3 = _createForOfIteratorHelper(Editor.positions(editor, _objectSpread({}, options, {\n      at: range,\n      reverse: true\n    }))),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var p = _step3.value;\n\n        if (d > distance) {\n          break;\n        }\n\n        if (d !== 0) {\n          target = p;\n        }\n\n        d++;\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\n  deleteBackward: function deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit = options.unit,\n        unit = _options$unit === void 0 ? 'character' : _options$unit;\n    editor.deleteBackward(unit);\n  },\n\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\n  deleteForward: function deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$unit2 = options.unit,\n        unit = _options$unit2 === void 0 ? 'character' : _options$unit2;\n    editor.deleteForward(unit);\n  },\n\n  /**\r\n   * Delete the content in the current selection.\r\n   */\n  deleteFragment: function deleteFragment(editor) {\n    editor.deleteFragment();\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges: function edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end: function end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first: function first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment: function fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks: function hasBlocks(editor, element) {\n    return element.children.some(function (n) {\n      return Editor.isBlock(editor, n);\n    });\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines: function hasInlines(editor, element) {\n    return element.children.some(function (n) {\n      return Text.isText(n) || Editor.isInline(editor, n);\n    });\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts: function hasTexts(editor, element) {\n    return element.children.every(function (n) {\n      return Text.isText(n);\n    });\n  },\n\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertBreak: function insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertNode: function insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertText: function insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\n  isBlock: function isBlock(editor, value) {\n    return Element.isElement(value) && !editor.isInline(value);\n  },\n\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor: function isEditor(value) {\n    return isPlainObject(value) && typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd: function isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge: function isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty: function isEmpty(editor, element) {\n    var children = element.children;\n\n    var _children = _slicedToArray(children, 1),\n        first = _children[0];\n\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  },\n\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\n  isInline: function isInline(editor, value) {\n    return Element.isElement(value) && editor.isInline(value);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing: function isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\n  isStart: function isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\n  isVoid: function isVoid(editor, value) {\n    return Element.isElement(value) && editor.isVoid(value);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last: function last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf: function leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  levels: /*#__PURE__*/_regeneratorRuntime.mark(function levels(editor) {\n    var options,\n        _options$at2,\n        at,\n        _options$reverse,\n        reverse,\n        _options$voids2,\n        voids,\n        match,\n        levels,\n        path,\n        _iterator4,\n        _step4,\n        _step4$value,\n        n,\n        p,\n        _args = arguments;\n\n    return _regeneratorRuntime.wrap(function levels$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            _options$at2 = options.at, at = _options$at2 === void 0 ? editor.selection : _options$at2, _options$reverse = options.reverse, reverse = _options$reverse === void 0 ? false : _options$reverse, _options$voids2 = options.voids, voids = _options$voids2 === void 0 ? false : _options$voids2;\n            match = options.match;\n\n            if (match == null) {\n              match = function match() {\n                return true;\n              };\n            }\n\n            if (at) {\n              _context.next = 6;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 6:\n            levels = [];\n            path = Editor.path(editor, at);\n            _iterator4 = _createForOfIteratorHelper(Node.levels(editor, path));\n            _context.prev = 9;\n\n            _iterator4.s();\n\n          case 11:\n            if ((_step4 = _iterator4.n()).done) {\n              _context.next = 20;\n              break;\n            }\n\n            _step4$value = _slicedToArray(_step4.value, 2), n = _step4$value[0], p = _step4$value[1];\n\n            if (match(n)) {\n              _context.next = 15;\n              break;\n            }\n\n            return _context.abrupt(\"continue\", 18);\n\n          case 15:\n            levels.push([n, p]);\n\n            if (!(!voids && Editor.isVoid(editor, n))) {\n              _context.next = 18;\n              break;\n            }\n\n            return _context.abrupt(\"break\", 20);\n\n          case 18:\n            _context.next = 11;\n            break;\n\n          case 20:\n            _context.next = 25;\n            break;\n\n          case 22:\n            _context.prev = 22;\n            _context.t0 = _context[\"catch\"](9);\n\n            _iterator4.e(_context.t0);\n\n          case 25:\n            _context.prev = 25;\n\n            _iterator4.f();\n\n            return _context.finish(25);\n\n          case 28:\n            if (reverse) {\n              levels.reverse();\n            }\n\n            return _context.delegateYield(levels, \"t1\", 30);\n\n          case 30:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, levels, null, [[9, 22, 25, 28]]);\n  }),\n\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\n  marks: function marks(editor) {\n    var marks = editor.marks,\n        selection = editor.selection;\n\n    if (!selection) {\n      return null;\n    }\n\n    if (marks) {\n      return marks;\n    }\n\n    if (Range.isExpanded(selection)) {\n      var _Editor$nodes = Editor.nodes(editor, {\n        match: Text.isText\n      }),\n          _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n          match = _Editor$nodes2[0];\n\n      if (match) {\n        var _match = _slicedToArray(match, 1),\n            _node = _match[0];\n\n        var _rest = _objectWithoutProperties(_node, [\"text\"]);\n\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n\n    var anchor = selection.anchor;\n    var path = anchor.path;\n\n    var _Editor$leaf = Editor.leaf(editor, path),\n        _Editor$leaf2 = _slicedToArray(_Editor$leaf, 1),\n        node = _Editor$leaf2[0];\n\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var block = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        }\n      });\n\n      if (prev && block) {\n        var _prev2 = _slicedToArray(prev, 2),\n            prevNode = _prev2[0],\n            prevPath = _prev2[1];\n\n        var _block = _slicedToArray(block, 2),\n            blockPath = _block[1];\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n\n    var rest = _objectWithoutProperties(node, [\"text\"]);\n\n    return rest;\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next: function next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode2 = options.mode,\n        mode = _options$mode2 === void 0 ? 'lowest' : _options$mode2,\n        _options$voids3 = options.voids,\n        voids = _options$voids3 === void 0 ? false : _options$voids3;\n    var match = options.match,\n        _options$at3 = options.at,\n        at = _options$at3 === void 0 ? editor.selection : _options$at3;\n\n    if (!at) {\n      return;\n    }\n\n    var _Editor$last = Editor.last(editor, at),\n        _Editor$last2 = _slicedToArray(_Editor$last, 2),\n        from = _Editor$last2[1];\n\n    var _Editor$last3 = Editor.last(editor, []),\n        _Editor$last4 = _slicedToArray(_Editor$last3, 2),\n        to = _Editor$last4[1];\n\n    var span = [from, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent = Editor.parent(editor, at),\n            _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n            parent = _Editor$parent2[0];\n\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match() {\n          return true;\n        };\n      }\n    }\n\n    var _Editor$nodes3 = Editor.nodes(editor, {\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n        _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 2),\n        next = _Editor$nodes4[1];\n\n    return next;\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node: function node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  nodes: /*#__PURE__*/_regeneratorRuntime.mark(function nodes(editor) {\n    var options,\n        _options$at4,\n        at,\n        _options$mode3,\n        mode,\n        _options$universal,\n        universal,\n        _options$reverse2,\n        reverse,\n        _options$voids4,\n        voids,\n        match,\n        from,\n        to,\n        first,\n        last,\n        iterable,\n        matches,\n        hit,\n        _iterator5,\n        _step5,\n        _step5$value,\n        node,\n        path,\n        isLower,\n        emit,\n        _args2 = arguments;\n\n    return _regeneratorRuntime.wrap(function nodes$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};\n            _options$at4 = options.at, at = _options$at4 === void 0 ? editor.selection : _options$at4, _options$mode3 = options.mode, mode = _options$mode3 === void 0 ? 'all' : _options$mode3, _options$universal = options.universal, universal = _options$universal === void 0 ? false : _options$universal, _options$reverse2 = options.reverse, reverse = _options$reverse2 === void 0 ? false : _options$reverse2, _options$voids4 = options.voids, voids = _options$voids4 === void 0 ? false : _options$voids4;\n            match = options.match;\n\n            if (!match) {\n              match = function match() {\n                return true;\n              };\n            }\n\n            if (at) {\n              _context2.next = 6;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 6:\n            if (Span.isSpan(at)) {\n              from = at[0];\n              to = at[1];\n            } else {\n              first = Editor.path(editor, at, {\n                edge: 'start'\n              });\n              last = Editor.path(editor, at, {\n                edge: 'end'\n              });\n              from = reverse ? last : first;\n              to = reverse ? first : last;\n            }\n\n            iterable = Node.nodes(editor, {\n              reverse: reverse,\n              from: from,\n              to: to,\n              pass: function pass(_ref) {\n                var _ref6 = _slicedToArray(_ref, 1),\n                    n = _ref6[0];\n\n                return voids ? false : Editor.isVoid(editor, n);\n              }\n            });\n            matches = [];\n            _iterator5 = _createForOfIteratorHelper(iterable);\n            _context2.prev = 10;\n\n            _iterator5.s();\n\n          case 12:\n            if ((_step5 = _iterator5.n()).done) {\n              _context2.next = 37;\n              break;\n            }\n\n            _step5$value = _slicedToArray(_step5.value, 2), node = _step5$value[0], path = _step5$value[1];\n            isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n            if (!(mode === 'highest' && isLower)) {\n              _context2.next = 17;\n              break;\n            }\n\n            return _context2.abrupt(\"continue\", 35);\n\n          case 17:\n            if (match(node)) {\n              _context2.next = 23;\n              break;\n            }\n\n            if (!(universal && !isLower && Text.isText(node))) {\n              _context2.next = 22;\n              break;\n            }\n\n            return _context2.abrupt(\"return\");\n\n          case 22:\n            return _context2.abrupt(\"continue\", 35);\n\n          case 23:\n            if (!(mode === 'lowest' && isLower)) {\n              _context2.next = 26;\n              break;\n            }\n\n            hit = [node, path];\n            return _context2.abrupt(\"continue\", 35);\n\n          case 26:\n            // In lowest mode we emit the last hit, once it's guaranteed lowest.\n            emit = mode === 'lowest' ? hit : [node, path];\n\n            if (!emit) {\n              _context2.next = 34;\n              break;\n            }\n\n            if (!universal) {\n              _context2.next = 32;\n              break;\n            }\n\n            matches.push(emit);\n            _context2.next = 34;\n            break;\n\n          case 32:\n            _context2.next = 34;\n            return emit;\n\n          case 34:\n            hit = [node, path];\n\n          case 35:\n            _context2.next = 12;\n            break;\n\n          case 37:\n            _context2.next = 42;\n            break;\n\n          case 39:\n            _context2.prev = 39;\n            _context2.t0 = _context2[\"catch\"](10);\n\n            _iterator5.e(_context2.t0);\n\n          case 42:\n            _context2.prev = 42;\n\n            _iterator5.f();\n\n            return _context2.finish(42);\n\n          case 45:\n            if (!(mode === 'lowest' && hit)) {\n              _context2.next = 52;\n              break;\n            }\n\n            if (!universal) {\n              _context2.next = 50;\n              break;\n            }\n\n            matches.push(hit);\n            _context2.next = 52;\n            break;\n\n          case 50:\n            _context2.next = 52;\n            return hit;\n\n          case 52:\n            if (!universal) {\n              _context2.next = 54;\n              break;\n            }\n\n            return _context2.delegateYield(matches, \"t1\", 54);\n\n          case 54:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, nodes, null, [[10, 39, 42, 45]]);\n  }),\n\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize: function normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$force = options.force,\n        force = _options$force === void 0 ? false : _options$force;\n\n    var getDirtyPaths = function getDirtyPaths(editor) {\n      return DIRTY_PATHS.get(editor) || [];\n    };\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), function (_ref2) {\n        var _ref7 = _slicedToArray(_ref2, 2),\n            p = _ref7[1];\n\n        return p;\n      });\n      DIRTY_PATHS.set(editor, allPaths);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, function () {\n      var max = getDirtyPaths(editor).length * 42; // HACK: better way?\n\n      var m = 0;\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(\"\\n            Could not completely normalize the editor after \".concat(max, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\\n          \"));\n        }\n\n        var path = getDirtyPaths(editor).pop();\n        var entry = Editor.node(editor, path);\n        editor.normalizeNode(entry);\n        m++;\n      }\n    });\n  },\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent: function parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path: function path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var depth = options.depth,\n        edge = options.edge;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var _Node$first = Node.first(editor, at),\n            _Node$first2 = _slicedToArray(_Node$first, 2),\n            firstPath = _Node$first2[1];\n\n        at = firstPath;\n      } else if (edge === 'end') {\n        var _Node$last = Node.last(editor, at),\n            _Node$last2 = _slicedToArray(_Node$last, 2),\n            lastPath = _Node$last2[1];\n\n        at = lastPath;\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at);\n      } else if (edge === 'end') {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef: function pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity = options.affinity,\n        affinity = _options$affinity === void 0 ? 'forward' : _options$affinity;\n    var ref = {\n      current: path,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs: function pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point: function point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$edge = options.edge,\n        edge = _options$edge === void 0 ? 'start' : _options$edge;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var _Node$last3 = Node.last(editor, at),\n            _Node$last4 = _slicedToArray(_Node$last3, 2),\n            lastPath = _Node$last4[1];\n\n        path = lastPath;\n      } else {\n        var _Node$first3 = Node.first(editor, at),\n            _Node$first4 = _slicedToArray(_Node$first3, 2),\n            firstPath = _Node$first4[1];\n\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path: path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (Range.isRange(at)) {\n      var _Range$edges = Range.edges(at),\n          _Range$edges2 = _slicedToArray(_Range$edges, 2),\n          start = _Range$edges2[0],\n          end = _Range$edges2[1];\n\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef: function pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity2 = options.affinity,\n        affinity = _options$affinity2 === void 0 ? 'forward' : _options$affinity2;\n    var ref = {\n      current: point,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs: function pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Iterate through all of the positions in the document where a `Point` can be\r\n   * placed.\r\n   *\r\n   * By default it will move forward by individual offsets at a time,  but you\r\n   * can pass the `unit: 'character'` option to moved forward one character, word,\r\n   * or line at at time.\r\n   *\r\n   * Note: void nodes are treated as a single point, and iteration will not\r\n   * happen inside their content.\r\n   */\n  positions: /*#__PURE__*/_regeneratorRuntime.mark(function positions(editor) {\n    var options,\n        _options$at5,\n        at,\n        _options$unit3,\n        unit,\n        _options$reverse3,\n        reverse$1,\n        range,\n        _Range$edges3,\n        _Range$edges4,\n        start,\n        end,\n        first,\n        string,\n        available,\n        offset,\n        distance,\n        isNewBlock,\n        advance,\n        _iterator6,\n        _step6,\n        _step6$value,\n        node,\n        path,\n        e,\n        s,\n        text,\n        isFirst,\n        _args3 = arguments;\n\n    return _regeneratorRuntime.wrap(function positions$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            options = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {};\n            _options$at5 = options.at, at = _options$at5 === void 0 ? editor.selection : _options$at5, _options$unit3 = options.unit, unit = _options$unit3 === void 0 ? 'offset' : _options$unit3, _options$reverse3 = options.reverse, reverse$1 = _options$reverse3 === void 0 ? false : _options$reverse3;\n\n            if (at) {\n              _context3.next = 4;\n              break;\n            }\n\n            return _context3.abrupt(\"return\");\n\n          case 4:\n            range = Editor.range(editor, at);\n            _Range$edges3 = Range.edges(range), _Range$edges4 = _slicedToArray(_Range$edges3, 2), start = _Range$edges4[0], end = _Range$edges4[1];\n            first = reverse$1 ? end : start;\n            string = '';\n            available = 0;\n            offset = 0;\n            distance = null;\n            isNewBlock = false;\n\n            advance = function advance() {\n              if (distance == null) {\n                if (unit === 'character') {\n                  distance = getCharacterDistance(string);\n                } else if (unit === 'word') {\n                  distance = getWordDistance(string);\n                } else if (unit === 'line' || unit === 'block') {\n                  distance = string.length;\n                } else {\n                  distance = 1;\n                }\n\n                string = string.slice(distance);\n              } // Add or substract the offset.\n\n\n              offset = reverse$1 ? offset - distance : offset + distance; // Subtract the distance traveled from the available text.\n\n              available = available - distance; // If the available had room to spare, reset the distance so that it will\n              // advance again next time. Otherwise, set it to the overflow amount.\n\n              distance = available >= 0 ? null : 0 - available;\n            };\n\n            _iterator6 = _createForOfIteratorHelper(Editor.nodes(editor, {\n              at: at,\n              reverse: reverse$1\n            }));\n            _context3.prev = 14;\n\n            _iterator6.s();\n\n          case 16:\n            if ((_step6 = _iterator6.n()).done) {\n              _context3.next = 51;\n              break;\n            }\n\n            _step6$value = _slicedToArray(_step6.value, 2), node = _step6$value[0], path = _step6$value[1];\n\n            if (!Element.isElement(node)) {\n              _context3.next = 26;\n              break;\n            }\n\n            if (!editor.isVoid(node)) {\n              _context3.next = 23;\n              break;\n            }\n\n            _context3.next = 22;\n            return Editor.start(editor, path);\n\n          case 22:\n            return _context3.abrupt(\"continue\", 49);\n\n          case 23:\n            if (!editor.isInline(node)) {\n              _context3.next = 25;\n              break;\n            }\n\n            return _context3.abrupt(\"continue\", 49);\n\n          case 25:\n            if (Editor.hasInlines(editor, node)) {\n              e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n              s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n              text = Editor.string(editor, {\n                anchor: s,\n                focus: e\n              });\n              string = reverse$1 ? reverse(text) : text;\n              isNewBlock = true;\n            }\n\n          case 26:\n            if (!Text.isText(node)) {\n              _context3.next = 49;\n              break;\n            }\n\n            isFirst = Path.equals(path, first.path);\n            available = node.text.length;\n            offset = reverse$1 ? available : 0;\n\n            if (isFirst) {\n              available = reverse$1 ? first.offset : available - first.offset;\n              offset = first.offset;\n            }\n\n            if (!(isFirst || isNewBlock || unit === 'offset')) {\n              _context3.next = 34;\n              break;\n            }\n\n            _context3.next = 34;\n            return {\n              path: path,\n              offset: offset\n            };\n\n          case 34:\n            if (!true) {\n              _context3.next = 48;\n              break;\n            }\n\n            if (!(string === '')) {\n              _context3.next = 39;\n              break;\n            }\n\n            return _context3.abrupt(\"break\", 48);\n\n          case 39:\n            advance();\n\n          case 40:\n            if (!(available >= 0)) {\n              _context3.next = 45;\n              break;\n            }\n\n            _context3.next = 43;\n            return {\n              path: path,\n              offset: offset\n            };\n\n          case 43:\n            _context3.next = 46;\n            break;\n\n          case 45:\n            return _context3.abrupt(\"break\", 48);\n\n          case 46:\n            _context3.next = 34;\n            break;\n\n          case 48:\n            isNewBlock = false;\n\n          case 49:\n            _context3.next = 16;\n            break;\n\n          case 51:\n            _context3.next = 56;\n            break;\n\n          case 53:\n            _context3.prev = 53;\n            _context3.t0 = _context3[\"catch\"](14);\n\n            _iterator6.e(_context3.t0);\n\n          case 56:\n            _context3.prev = 56;\n\n            _iterator6.f();\n\n            return _context3.finish(56);\n\n          case 59:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, positions, null, [[14, 53, 56, 59]]);\n  }),\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous: function previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode4 = options.mode,\n        mode = _options$mode4 === void 0 ? 'lowest' : _options$mode4,\n        _options$voids5 = options.voids,\n        voids = _options$voids5 === void 0 ? false : _options$voids5;\n    var match = options.match,\n        _options$at6 = options.at,\n        at = _options$at6 === void 0 ? editor.selection : _options$at6;\n\n    if (!at) {\n      return;\n    }\n\n    var _Editor$first = Editor.first(editor, at),\n        _Editor$first2 = _slicedToArray(_Editor$first, 2),\n        from = _Editor$first2[1];\n\n    var _Editor$first3 = Editor.first(editor, []),\n        _Editor$first4 = _slicedToArray(_Editor$first3, 2),\n        to = _Editor$first4[1];\n\n    var span = [from, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var _Editor$parent3 = Editor.parent(editor, at),\n            _Editor$parent4 = _slicedToArray(_Editor$parent3, 1),\n            parent = _Editor$parent4[0];\n\n        match = function match(n) {\n          return parent.children.includes(n);\n        };\n      } else {\n        match = function match() {\n          return true;\n        };\n      }\n    }\n\n    var _Editor$nodes5 = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match: match,\n      mode: mode,\n      voids: voids\n    }),\n        _Editor$nodes6 = _slicedToArray(_Editor$nodes5, 2),\n        previous = _Editor$nodes6[1];\n\n    return previous;\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range: function range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef: function rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$affinity3 = options.affinity,\n        affinity = _options$affinity3 === void 0 ? 'forward' : _options$affinity3;\n    var ref = {\n      current: range,\n      affinity: affinity,\n      unref: function unref() {\n        var current = ref.current;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs[\"delete\"](ref);\n        ref.current = null;\n        return current;\n      }\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs: function rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\n  removeMark: function removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start: function start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: the text of void nodes is presumed to be an empty string, regardless\r\n   * of what their actual content is.\r\n   */\n  string: function string(editor, at) {\n    var range = Editor.range(editor, at);\n\n    var _Range$edges5 = Range.edges(range),\n        _Range$edges6 = _slicedToArray(_Range$edges5, 2),\n        start = _Range$edges6[0],\n        end = _Range$edges6[1];\n\n    var text = '';\n\n    var _iterator7 = _createForOfIteratorHelper(Editor.nodes(editor, {\n      at: range,\n      match: Text.isText\n    })),\n        _step7;\n\n    try {\n      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n        var _step7$value = _slicedToArray(_step7.value, 2),\n            node = _step7$value[0],\n            path = _step7$value[1];\n\n        var t = node.text;\n\n        if (Path.equals(path, end.path)) {\n          t = t.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          t = t.slice(start.offset);\n        }\n\n        text += t;\n      }\n    } catch (err) {\n      _iterator7.e(err);\n    } finally {\n      _iterator7.f();\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform: function transform(editor, op) {\n    editor.children = createDraft(editor.children);\n    var selection = editor.selection && createDraft(editor.selection);\n\n    switch (op.type) {\n      case 'insert_node':\n        {\n          var path = op.path,\n              node = op.node;\n          var parent = Node.parent(editor, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 0, node);\n\n          if (selection) {\n            var _iterator8 = _createForOfIteratorHelper(Range.points(selection)),\n                _step8;\n\n            try {\n              for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n                var _step8$value = _slicedToArray(_step8.value, 2),\n                    point = _step8$value[0],\n                    key = _step8$value[1];\n\n                selection[key] = Point.transform(point, op);\n              }\n            } catch (err) {\n              _iterator8.e(err);\n            } finally {\n              _iterator8.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'insert_text':\n        {\n          var _path = op.path,\n              offset = op.offset,\n              text = op.text;\n\n          var _node2 = Node.leaf(editor, _path);\n\n          var before = _node2.text.slice(0, offset);\n\n          var after = _node2.text.slice(offset);\n\n          _node2.text = before + text + after;\n\n          if (selection) {\n            var _iterator9 = _createForOfIteratorHelper(Range.points(selection)),\n                _step9;\n\n            try {\n              for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                var _step9$value = _slicedToArray(_step9.value, 2),\n                    _point = _step9$value[0],\n                    _key = _step9$value[1];\n\n                selection[_key] = Point.transform(_point, op);\n              }\n            } catch (err) {\n              _iterator9.e(err);\n            } finally {\n              _iterator9.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var _path2 = op.path;\n\n          var _node3 = Node.get(editor, _path2);\n\n          var prevPath = Path.previous(_path2);\n          var prev = Node.get(editor, prevPath);\n\n          var _parent = Node.parent(editor, _path2);\n\n          var _index = _path2[_path2.length - 1];\n\n          if (Text.isText(_node3) && Text.isText(prev)) {\n            prev.text += _node3.text;\n          } else if (!Text.isText(_node3) && !Text.isText(prev)) {\n            var _prev$children;\n\n            (_prev$children = prev.children).push.apply(_prev$children, _toConsumableArray(_node3.children));\n          } else {\n            throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interaces: \").concat(_node3, \" \").concat(prev));\n          }\n\n          _parent.children.splice(_index, 1);\n\n          if (selection) {\n            var _iterator10 = _createForOfIteratorHelper(Range.points(selection)),\n                _step10;\n\n            try {\n              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n                var _step10$value = _slicedToArray(_step10.value, 2),\n                    _point2 = _step10$value[0],\n                    _key2 = _step10$value[1];\n\n                selection[_key2] = Point.transform(_point2, op);\n              }\n            } catch (err) {\n              _iterator10.e(err);\n            } finally {\n              _iterator10.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var _path3 = op.path,\n              newPath = op.newPath;\n\n          if (Path.isAncestor(_path3, newPath)) {\n            throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n          }\n\n          var _node4 = Node.get(editor, _path3);\n\n          var _parent2 = Node.parent(editor, _path3);\n\n          var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n          // the same snapshot in time, there's a mismatch. After either\n          // removing the original position, the second step's path can be out\n          // of date. So instead of using the `op.newPath` directly, we\n          // transform `op.path` to ascertain what the `newPath` would be after\n          // the operation was applied.\n\n          _parent2.children.splice(_index2, 1);\n\n          var truePath = Path.transform(_path3, op);\n          var newParent = Node.get(editor, Path.parent(truePath));\n          var newIndex = truePath[truePath.length - 1];\n          newParent.children.splice(newIndex, 0, _node4);\n\n          if (selection) {\n            var _iterator11 = _createForOfIteratorHelper(Range.points(selection)),\n                _step11;\n\n            try {\n              for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n                var _step11$value = _slicedToArray(_step11.value, 2),\n                    _point3 = _step11$value[0],\n                    _key3 = _step11$value[1];\n\n                selection[_key3] = Point.transform(_point3, op);\n              }\n            } catch (err) {\n              _iterator11.e(err);\n            } finally {\n              _iterator11.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var _path4 = op.path;\n          var _index3 = _path4[_path4.length - 1];\n\n          var _parent3 = Node.parent(editor, _path4);\n\n          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n          // node that was removed we need to update the range or remove it.\n\n\n          if (selection) {\n            var _iterator12 = _createForOfIteratorHelper(Range.points(selection)),\n                _step12;\n\n            try {\n              for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {\n                var _step12$value = _slicedToArray(_step12.value, 2),\n                    _point4 = _step12$value[0],\n                    _key4 = _step12$value[1];\n\n                var result = Point.transform(_point4, op);\n\n                if (selection != null && result != null) {\n                  selection[_key4] = result;\n                } else {\n                  var _prev = void 0;\n\n                  var next = void 0;\n\n                  var _iterator13 = _createForOfIteratorHelper(Node.texts(editor)),\n                      _step13;\n\n                  try {\n                    for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {\n                      var _step13$value = _slicedToArray(_step13.value, 2),\n                          n = _step13$value[0],\n                          p = _step13$value[1];\n\n                      if (Path.compare(p, _path4) === -1) {\n                        _prev = [n, p];\n                      } else {\n                        next = [n, p];\n                        break;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator13.e(err);\n                  } finally {\n                    _iterator13.f();\n                  }\n\n                  if (_prev) {\n                    _point4.path = _prev[1];\n                    _point4.offset = _prev[0].text.length;\n                  } else if (next) {\n                    _point4.path = next[1];\n                    _point4.offset = 0;\n                  } else {\n                    selection = null;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator12.e(err);\n            } finally {\n              _iterator12.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_text':\n        {\n          var _path5 = op.path,\n              _offset = op.offset,\n              _text2 = op.text;\n\n          var _node5 = Node.leaf(editor, _path5);\n\n          var _before = _node5.text.slice(0, _offset);\n\n          var _after = _node5.text.slice(_offset + _text2.length);\n\n          _node5.text = _before + _after;\n\n          if (selection) {\n            var _iterator14 = _createForOfIteratorHelper(Range.points(selection)),\n                _step14;\n\n            try {\n              for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {\n                var _step14$value = _slicedToArray(_step14.value, 2),\n                    _point5 = _step14$value[0],\n                    _key5 = _step14$value[1];\n\n                selection[_key5] = Point.transform(_point5, op);\n              }\n            } catch (err) {\n              _iterator14.e(err);\n            } finally {\n              _iterator14.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'set_node':\n        {\n          var _path6 = op.path,\n              newProperties = op.newProperties;\n\n          if (_path6.length === 0) {\n            throw new Error(\"Cannot set properties on the root node!\");\n          }\n\n          var _node6 = Node.get(editor, _path6);\n\n          for (var _key6 in newProperties) {\n            if (_key6 === 'children' || _key6 === 'text') {\n              throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n            }\n\n            var value = newProperties[_key6];\n\n            if (value == null) {\n              delete _node6[_key6];\n            } else {\n              _node6[_key6] = value;\n            }\n          }\n\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var _newProperties = op.newProperties;\n\n          if (_newProperties == null) {\n            selection = _newProperties;\n          } else if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(JSON.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _newProperties;\n          } else {\n            Object.assign(selection, _newProperties);\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var _path7 = op.path,\n              position = op.position,\n              properties = op.properties;\n\n          if (_path7.length === 0) {\n            throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n          }\n\n          var _node7 = Node.get(editor, _path7);\n\n          var _parent4 = Node.parent(editor, _path7);\n\n          var _index4 = _path7[_path7.length - 1];\n          var newNode;\n\n          if (Text.isText(_node7)) {\n            var _before2 = _node7.text.slice(0, position);\n\n            var _after2 = _node7.text.slice(position);\n\n            _node7.text = _before2;\n            newNode = _objectSpread({}, _node7, {}, properties, {\n              text: _after2\n            });\n          } else {\n            var _before3 = _node7.children.slice(0, position);\n\n            var _after3 = _node7.children.slice(position);\n\n            _node7.children = _before3;\n            newNode = _objectSpread({}, _node7, {}, properties, {\n              children: _after3\n            });\n          }\n\n          _parent4.children.splice(_index4 + 1, 0, newNode);\n\n          if (selection) {\n            var _iterator15 = _createForOfIteratorHelper(Range.points(selection)),\n                _step15;\n\n            try {\n              for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {\n                var _step15$value = _slicedToArray(_step15.value, 2),\n                    _point6 = _step15$value[0],\n                    _key7 = _step15$value[1];\n\n                selection[_key7] = Point.transform(_point6, op);\n              }\n            } catch (err) {\n              _iterator15.e(err);\n            } finally {\n              _iterator15.f();\n            }\n          }\n\n          break;\n        }\n    }\n\n    editor.children = finishDraft(editor.children);\n\n    if (selection) {\n      editor.selection = isDraft(selection) ? finishDraft(selection) : selection;\n    } else {\n      editor.selection = null;\n    }\n  },\n\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange: function unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$voids6 = options.voids,\n        voids = _options$voids6 === void 0 ? false : _options$voids6;\n\n    var _Range$edges7 = Range.edges(range),\n        _Range$edges8 = _slicedToArray(_Range$edges7, 2),\n        start = _Range$edges8[0],\n        end = _Range$edges8[1]; // PERF: exit early if we can guarantee that the range isn't hanging.\n\n\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range;\n    }\n\n    var endBlock = Editor.above(editor, {\n      at: end,\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, []);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n\n    var _iterator16 = _createForOfIteratorHelper(Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids: voids\n    })),\n        _step16;\n\n    try {\n      for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {\n        var _step16$value = _slicedToArray(_step16.value, 2),\n            node = _step16$value[0],\n            path = _step16$value[1];\n\n        if (skip) {\n          skip = false;\n          continue;\n        }\n\n        if (node.text !== '' || Path.isBefore(path, blockPath)) {\n          end = {\n            path: path,\n            offset: node.text.length\n          };\n          break;\n        }\n      }\n    } catch (err) {\n      _iterator16.e(err);\n    } finally {\n      _iterator16.f();\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\n  \"void\": function _void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread({}, options, {\n      match: function match(n) {\n        return Editor.isVoid(editor, n);\n      }\n    }));\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing: function withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    NORMALIZING.set(editor, false);\n    fn();\n    NORMALIZING.set(editor, value);\n    Editor.normalize(editor);\n  }\n};\nvar Element = {\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement: function isElement(value) {\n    return isPlainObject(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList: function isElementList(value) {\n    return Array.isArray(value) && (value.length === 0 || Element.isElement(value[0]));\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches: function matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n};\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation: function isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n};\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan: function isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n};\nvar Node = {\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor: function ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return an iterable of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is bottom-up, from lowest to highest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go top-down.\r\n   */\n  ancestors: /*#__PURE__*/_regeneratorRuntime.mark(function ancestors(root, path) {\n    var options,\n        _iterator17,\n        _step17,\n        p,\n        n,\n        entry,\n        _args4 = arguments;\n\n    return _regeneratorRuntime.wrap(function ancestors$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            options = _args4.length > 2 && _args4[2] !== undefined ? _args4[2] : {};\n            _iterator17 = _createForOfIteratorHelper(Path.ancestors(path, options));\n            _context4.prev = 2;\n\n            _iterator17.s();\n\n          case 4:\n            if ((_step17 = _iterator17.n()).done) {\n              _context4.next = 12;\n              break;\n            }\n\n            p = _step17.value;\n            n = Node.ancestor(root, p);\n            entry = [n, p];\n            _context4.next = 10;\n            return entry;\n\n          case 10:\n            _context4.next = 4;\n            break;\n\n          case 12:\n            _context4.next = 17;\n            break;\n\n          case 14:\n            _context4.prev = 14;\n            _context4.t0 = _context4[\"catch\"](2);\n\n            _iterator17.e(_context4.t0);\n\n          case 17:\n            _context4.prev = 17;\n\n            _iterator17.f();\n\n            return _context4.finish(17);\n\n          case 20:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, ancestors, null, [[2, 14, 17, 20]]);\n  }),\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child: function child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(JSON.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(JSON.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\n  children: /*#__PURE__*/_regeneratorRuntime.mark(function children(root, path) {\n    var options,\n        _options$reverse4,\n        reverse,\n        ancestor,\n        children,\n        index,\n        child,\n        childPath,\n        _args5 = arguments;\n\n    return _regeneratorRuntime.wrap(function children$(_context5) {\n      while (1) {\n        switch (_context5.prev = _context5.next) {\n          case 0:\n            options = _args5.length > 2 && _args5[2] !== undefined ? _args5[2] : {};\n            _options$reverse4 = options.reverse, reverse = _options$reverse4 === void 0 ? false : _options$reverse4;\n            ancestor = Node.ancestor(root, path);\n            children = ancestor.children;\n            index = reverse ? children.length - 1 : 0;\n\n          case 5:\n            if (!(reverse ? index >= 0 : index < children.length)) {\n              _context5.next = 13;\n              break;\n            }\n\n            child = Node.child(ancestor, index);\n            childPath = path.concat(index);\n            _context5.next = 10;\n            return [child, childPath];\n\n          case 10:\n            index = reverse ? index - 1 : index + 1;\n            _context5.next = 5;\n            break;\n\n          case 13:\n          case \"end\":\n            return _context5.stop();\n        }\n      }\n    }, children);\n  }),\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common: function common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant: function descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return an iterable of all the descendant node entries inside a root node.\r\n   */\n  descendants: /*#__PURE__*/_regeneratorRuntime.mark(function descendants(root) {\n    var options,\n        _iterator18,\n        _step18,\n        _step18$value,\n        node,\n        path,\n        _args6 = arguments;\n\n    return _regeneratorRuntime.wrap(function descendants$(_context6) {\n      while (1) {\n        switch (_context6.prev = _context6.next) {\n          case 0:\n            options = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : {};\n            _iterator18 = _createForOfIteratorHelper(Node.nodes(root, options));\n            _context6.prev = 2;\n\n            _iterator18.s();\n\n          case 4:\n            if ((_step18 = _iterator18.n()).done) {\n              _context6.next = 11;\n              break;\n            }\n\n            _step18$value = _slicedToArray(_step18.value, 2), node = _step18$value[0], path = _step18$value[1];\n\n            if (!(path.length !== 0)) {\n              _context6.next = 9;\n              break;\n            }\n\n            _context6.next = 9;\n            return [node, path];\n\n          case 9:\n            _context6.next = 4;\n            break;\n\n          case 11:\n            _context6.next = 16;\n            break;\n\n          case 13:\n            _context6.prev = 13;\n            _context6.t0 = _context6[\"catch\"](2);\n\n            _iterator18.e(_context6.t0);\n\n          case 16:\n            _context6.prev = 16;\n\n            _iterator18.f();\n\n            return _context6.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context6.stop();\n        }\n      }\n    }, descendants, null, [[2, 13, 16, 19]]);\n  }),\n\n  /**\r\n   * Return an iterable of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  elements: /*#__PURE__*/_regeneratorRuntime.mark(function elements(root) {\n    var options,\n        _iterator19,\n        _step19,\n        _step19$value,\n        node,\n        path,\n        _args7 = arguments;\n\n    return _regeneratorRuntime.wrap(function elements$(_context7) {\n      while (1) {\n        switch (_context7.prev = _context7.next) {\n          case 0:\n            options = _args7.length > 1 && _args7[1] !== undefined ? _args7[1] : {};\n            _iterator19 = _createForOfIteratorHelper(Node.nodes(root, options));\n            _context7.prev = 2;\n\n            _iterator19.s();\n\n          case 4:\n            if ((_step19 = _iterator19.n()).done) {\n              _context7.next = 11;\n              break;\n            }\n\n            _step19$value = _slicedToArray(_step19.value, 2), node = _step19$value[0], path = _step19$value[1];\n\n            if (!Element.isElement(node)) {\n              _context7.next = 9;\n              break;\n            }\n\n            _context7.next = 9;\n            return [node, path];\n\n          case 9:\n            _context7.next = 4;\n            break;\n\n          case 11:\n            _context7.next = 16;\n            break;\n\n          case 13:\n            _context7.prev = 13;\n            _context7.t0 = _context7[\"catch\"](2);\n\n            _iterator19.e(_context7.t0);\n\n          case 16:\n            _context7.prev = 16;\n\n            _iterator19.f();\n\n            return _context7.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context7.stop();\n        }\n      }\n    }, elements, null, [[2, 13, 16, 19]]);\n  }),\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first: function first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment: function fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(JSON.stringify(root)));\n    }\n\n    var newRoot = produce(root, function (r) {\n      var _Range$edges9 = Range.edges(range),\n          _Range$edges10 = _slicedToArray(_Range$edges9, 2),\n          start = _Range$edges10[0],\n          end = _Range$edges10[1];\n\n      var iterable = Node.nodes(r, {\n        reverse: true,\n        pass: function pass(_ref) {\n          var _ref8 = _slicedToArray(_ref, 2),\n              path = _ref8[1];\n\n          return !Range.includes(range, path);\n        }\n      });\n\n      var _iterator20 = _createForOfIteratorHelper(iterable),\n          _step20;\n\n      try {\n        for (_iterator20.s(); !(_step20 = _iterator20.n()).done;) {\n          var _step20$value = _slicedToArray(_step20.value, 2),\n              path = _step20$value[1];\n\n          if (!Range.includes(range, path)) {\n            var parent = Node.parent(r, path);\n            var index = path[path.length - 1];\n            parent.children.splice(index, 1);\n          }\n\n          if (Path.equals(path, end.path)) {\n            var leaf = Node.leaf(r, path);\n            leaf.text = leaf.text.slice(0, end.offset);\n          }\n\n          if (Path.equals(path, start.path)) {\n            var _leaf = Node.leaf(r, path);\n\n            _leaf.text = _leaf.text.slice(start.offset);\n          }\n        }\n      } catch (err) {\n        _iterator20.e(err);\n      } finally {\n        _iterator20.f();\n      }\n\n      delete r.selection;\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get: function get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(JSON.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has: function has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode: function isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList: function isNodeList(value) {\n    return Array.isArray(value) && (value.length === 0 || Node.isNode(value[0]));\n  },\n\n  /**\r\n   * Get the lash node entry in a root node from a path.\r\n   */\n  last: function last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf: function leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(node));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return an iterable of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from lowest to highest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  levels: /*#__PURE__*/_regeneratorRuntime.mark(function levels(root, path) {\n    var options,\n        _iterator21,\n        _step21,\n        p,\n        n,\n        _args8 = arguments;\n\n    return _regeneratorRuntime.wrap(function levels$(_context8) {\n      while (1) {\n        switch (_context8.prev = _context8.next) {\n          case 0:\n            options = _args8.length > 2 && _args8[2] !== undefined ? _args8[2] : {};\n            _iterator21 = _createForOfIteratorHelper(Path.levels(path, options));\n            _context8.prev = 2;\n\n            _iterator21.s();\n\n          case 4:\n            if ((_step21 = _iterator21.n()).done) {\n              _context8.next = 11;\n              break;\n            }\n\n            p = _step21.value;\n            n = Node.get(root, p);\n            _context8.next = 9;\n            return [n, p];\n\n          case 9:\n            _context8.next = 4;\n            break;\n\n          case 11:\n            _context8.next = 16;\n            break;\n\n          case 13:\n            _context8.prev = 13;\n            _context8.t0 = _context8[\"catch\"](2);\n\n            _iterator21.e(_context8.t0);\n\n          case 16:\n            _context8.prev = 16;\n\n            _iterator21.f();\n\n            return _context8.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context8.stop();\n        }\n      }\n    }, levels, null, [[2, 13, 16, 19]]);\n  }),\n\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\n  matches: function matches(node, props) {\n    return Element.isElement(node) && Element.matches(node, props) || Text.isText(node) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Return an iterable of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  nodes: /*#__PURE__*/_regeneratorRuntime.mark(function nodes(root) {\n    var options,\n        pass,\n        _options$reverse5,\n        reverse,\n        _options$from,\n        from,\n        to,\n        visited,\n        p,\n        n,\n        nextIndex,\n        newPath,\n        _newPath,\n        _args9 = arguments;\n\n    return _regeneratorRuntime.wrap(function nodes$(_context9) {\n      while (1) {\n        switch (_context9.prev = _context9.next) {\n          case 0:\n            options = _args9.length > 1 && _args9[1] !== undefined ? _args9[1] : {};\n            pass = options.pass, _options$reverse5 = options.reverse, reverse = _options$reverse5 === void 0 ? false : _options$reverse5;\n            _options$from = options.from, from = _options$from === void 0 ? [] : _options$from, to = options.to;\n            visited = new Set();\n            p = [];\n            n = root;\n\n          case 6:\n            if (!true) {\n              _context9.next = 37;\n              break;\n            }\n\n            if (!(to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to)))) {\n              _context9.next = 9;\n              break;\n            }\n\n            return _context9.abrupt(\"break\", 37);\n\n          case 9:\n            if (visited.has(n)) {\n              _context9.next = 12;\n              break;\n            }\n\n            _context9.next = 12;\n            return [n, p];\n\n          case 12:\n            if (!(!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false))) {\n              _context9.next = 19;\n              break;\n            }\n\n            visited.add(n);\n            nextIndex = reverse ? n.children.length - 1 : 0;\n\n            if (Path.isAncestor(p, from)) {\n              nextIndex = from[p.length];\n            }\n\n            p = p.concat(nextIndex);\n            n = Node.get(root, p);\n            return _context9.abrupt(\"continue\", 6);\n\n          case 19:\n            if (!(p.length === 0)) {\n              _context9.next = 21;\n              break;\n            }\n\n            return _context9.abrupt(\"break\", 37);\n\n          case 21:\n            if (reverse) {\n              _context9.next = 27;\n              break;\n            }\n\n            newPath = Path.next(p);\n\n            if (!Node.has(root, newPath)) {\n              _context9.next = 27;\n              break;\n            }\n\n            p = newPath;\n            n = Node.get(root, p);\n            return _context9.abrupt(\"continue\", 6);\n\n          case 27:\n            if (!(reverse && p[p.length - 1] !== 0)) {\n              _context9.next = 32;\n              break;\n            }\n\n            _newPath = Path.previous(p);\n            p = _newPath;\n            n = Node.get(root, p);\n            return _context9.abrupt(\"continue\", 6);\n\n          case 32:\n            // Otherwise we're going upward...\n            p = Path.parent(p);\n            n = Node.get(root, p);\n            visited.add(n);\n            _context9.next = 6;\n            break;\n\n          case 37:\n          case \"end\":\n            return _context9.stop();\n        }\n      }\n    }, nodes);\n  }),\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent: function parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  string: function string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  /**\r\n   * Return an iterable of all leaf text nodes in a root node.\r\n   */\n  texts: /*#__PURE__*/_regeneratorRuntime.mark(function texts(root) {\n    var options,\n        _iterator22,\n        _step22,\n        _step22$value,\n        node,\n        path,\n        _args10 = arguments;\n\n    return _regeneratorRuntime.wrap(function texts$(_context10) {\n      while (1) {\n        switch (_context10.prev = _context10.next) {\n          case 0:\n            options = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : {};\n            _iterator22 = _createForOfIteratorHelper(Node.nodes(root, options));\n            _context10.prev = 2;\n\n            _iterator22.s();\n\n          case 4:\n            if ((_step22 = _iterator22.n()).done) {\n              _context10.next = 11;\n              break;\n            }\n\n            _step22$value = _slicedToArray(_step22.value, 2), node = _step22$value[0], path = _step22$value[1];\n\n            if (!Text.isText(node)) {\n              _context10.next = 9;\n              break;\n            }\n\n            _context10.next = 9;\n            return [node, path];\n\n          case 9:\n            _context10.next = 4;\n            break;\n\n          case 11:\n            _context10.next = 16;\n            break;\n\n          case 13:\n            _context10.prev = 13;\n            _context10.t0 = _context10[\"catch\"](2);\n\n            _iterator22.e(_context10.t0);\n\n          case 16:\n            _context10.prev = 16;\n\n            _iterator22.f();\n\n            return _context10.finish(16);\n\n          case 19:\n          case \"end\":\n            return _context10.stop();\n        }\n      }\n    }, texts, null, [[2, 13, 16, 19]]);\n  })\n};\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$1(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$1(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Operation = {\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation: function isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\n  isOperation: function isOperation(value) {\n    if (!isPlainObject(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && (typeof value.target === 'number' || value.target === null) && Path.isPath(value.path) && isPlainObject(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && (typeof value.target === 'number' || value.target === null) && isPlainObject(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList: function isOperationList(value) {\n    return Array.isArray(value) && (value.length === 0 || Operation.isOperation(value[0]));\n  },\n\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation: function isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\n  isTextOperation: function isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse: function inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var newPath = op.newPath,\n              path = op.path; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // We need to get the original path here, but sometimes the `newPath`\n          // is a younger sibling of (or ends before) the original, and this\n          // accounts for it.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$1({}, op, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var properties = op.properties,\n              newProperties = op.newProperties;\n          return _objectSpread$1({}, op, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var _properties = op.properties,\n              _newProperties = op.newProperties;\n\n          if (_properties == null) {\n            return _objectSpread$1({}, op, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$1({}, op, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$1({}, op, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$1({}, op, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n};\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from deepest to shallowest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors: function ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse6 = options.reverse,\n        reverse = _options$reverse6 === void 0 ? false : _options$reverse6;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common: function common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare: function compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter: function endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt: function endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore: function endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals: function equals(path, another) {\n    return path.length === another.length && path.every(function (n, i) {\n      return n === another[i];\n    });\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter: function isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor: function isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore: function isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild: function isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon: function isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant: function isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent: function isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath: function isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling: function isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels: function levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse7 = options.reverse,\n        reverse = _options$reverse7 === void 0 ? false : _options$reverse7;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next: function next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent: function parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous: function previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative: function relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform: function transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(path, function (p) {\n      var _options$affinity4 = options.affinity,\n          affinity = _options$affinity4 === void 0 ? 'forward' : _options$affinity4; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n      if (path.length === 0) {\n        return;\n      }\n\n      switch (operation.type) {\n        case 'insert_node':\n          {\n            var op = operation.path;\n\n            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n              p[op.length - 1] += 1;\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            var _op = operation.path;\n\n            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n              return null;\n            } else if (Path.endsBefore(_op, p)) {\n              p[_op.length - 1] -= 1;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            var _op2 = operation.path,\n                position = operation.position;\n\n            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n            } else if (Path.isAncestor(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n              p[_op2.length] += position;\n            }\n\n            break;\n          }\n\n        case 'split_node':\n          {\n            var _op3 = operation.path,\n                _position = operation.position;\n\n            if (Path.equals(_op3, p)) {\n              if (affinity === 'forward') {\n                p[p.length - 1] += 1;\n              } else if (affinity === 'backward') ;else {\n                return null;\n              }\n            } else if (Path.endsBefore(_op3, p)) {\n              p[_op3.length - 1] += 1;\n            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n              p[_op3.length - 1] += 1;\n              p[_op3.length] -= _position;\n            }\n\n            break;\n          }\n\n        case 'move_node':\n          {\n            var _op4 = operation.path,\n                onp = operation.newPath; // If the old and new path are the same, it's a no-op.\n\n            if (Path.equals(_op4, onp)) {\n              return;\n            }\n\n            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n              var copy = onp.slice();\n\n              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                var i = Math.min(onp.length, _op4.length) - 1;\n                copy[i] -= 1;\n              }\n\n              return copy.concat(p.slice(_op4.length));\n            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              }\n\n              p[onp.length - 1] += 1;\n            } else if (Path.endsBefore(_op4, p)) {\n              if (Path.equals(onp, p)) {\n                p[onp.length - 1] += 1;\n              }\n\n              p[_op4.length - 1] -= 1;\n            }\n\n            break;\n          }\n      }\n    });\n  }\n};\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$2(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$2(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare: function compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter: function isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore: function isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals: function equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint: function isPoint(value) {\n    return isPlainObject(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform: function transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return produce(point, function (p) {\n      var _options$affinity5 = options.affinity,\n          affinity = _options$affinity5 === void 0 ? 'forward' : _options$affinity5;\n      var path = p.path,\n          offset = p.offset;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$2({}, options, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n};\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$3(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$3(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges: function edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$reverse8 = options.reverse,\n        reverse = _options$reverse8 === void 0 ? false : _options$reverse8;\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end: function end(range) {\n    var _Range$edges11 = Range.edges(range),\n        _Range$edges12 = _slicedToArray(_Range$edges11, 2),\n        end = _Range$edges12[1];\n\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals: function equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes: function includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var _Range$edges13 = Range.edges(range),\n          _Range$edges14 = _slicedToArray(_Range$edges13, 2),\n          rs = _Range$edges14[0],\n          re = _Range$edges14[1];\n\n      var _Range$edges15 = Range.edges(target),\n          _Range$edges16 = _slicedToArray(_Range$edges15, 2),\n          ts = _Range$edges16[0],\n          te = _Range$edges16[1];\n\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var _Range$edges17 = Range.edges(range),\n        _Range$edges18 = _slicedToArray(_Range$edges17, 2),\n        start = _Range$edges18[0],\n        end = _Range$edges18[1];\n\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection: function intersection(range, another) {\n    var rest = _objectWithoutProperties(range, [\"anchor\", \"focus\"]);\n\n    var _Range$edges19 = Range.edges(range),\n        _Range$edges20 = _slicedToArray(_Range$edges19, 2),\n        s1 = _Range$edges20[0],\n        e1 = _Range$edges20[1];\n\n    var _Range$edges21 = Range.edges(another),\n        _Range$edges22 = _slicedToArray(_Range$edges21, 2),\n        s2 = _Range$edges22[0],\n        e2 = _Range$edges22[1];\n\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$3({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward: function isBackward(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed: function isCollapsed(range) {\n    var anchor = range.anchor,\n        focus = range.focus;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded: function isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward: function isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange: function isRange(value) {\n    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  points: /*#__PURE__*/_regeneratorRuntime.mark(function points(range) {\n    return _regeneratorRuntime.wrap(function points$(_context11) {\n      while (1) {\n        switch (_context11.prev = _context11.next) {\n          case 0:\n            _context11.next = 2;\n            return [range.anchor, 'anchor'];\n\n          case 2:\n            _context11.next = 4;\n            return [range.focus, 'focus'];\n\n          case 4:\n          case \"end\":\n            return _context11.stop();\n        }\n      }\n    }, points);\n  }),\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start: function start(range) {\n    var _Range$edges23 = Range.edges(range),\n        _Range$edges24 = _slicedToArray(_Range$edges23, 1),\n        start = _Range$edges24[0];\n\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform: function transform(range, op, options) {\n    var _options$affinity6 = options.affinity,\n        affinity = _options$affinity6 === void 0 ? 'inward' : _options$affinity6;\n    var affinityAnchor;\n    var affinityFocus;\n\n    if (affinity === 'inward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      } else {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      }\n    } else if (affinity === 'outward') {\n      if (Range.isForward(range)) {\n        affinityAnchor = 'backward';\n        affinityFocus = 'forward';\n      } else {\n        affinityAnchor = 'forward';\n        affinityFocus = 'backward';\n      }\n    } else {\n      affinityAnchor = affinity;\n      affinityFocus = affinity;\n    }\n\n    return produce(range, function (r) {\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n};\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform: function transform(ref, op) {\n    var current = ref.current,\n        affinity = ref.affinity;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity: affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n};\n\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$4(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$4(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$4(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Text = {\n  /**\r\n   * Check if two text nodes are equal.\r\n   */\n  equals: function equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _options$loose = options.loose,\n        loose = _options$loose === void 0 ? false : _options$loose;\n\n    for (var key in text) {\n      if (loose && key === 'text') {\n        continue;\n      }\n\n      if (text[key] !== another[key]) {\n        return false;\n      }\n    }\n\n    for (var _key in another) {\n      if (loose && _key === 'text') {\n        continue;\n      }\n\n      if (text[_key] !== another[_key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText: function isText(value) {\n    return isPlainObject(value) && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList: function isTextList(value) {\n    return Array.isArray(value) && (value.length === 0 || Text.isText(value[0]));\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\n  matches: function matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\n  decorations: function decorations(node, _decorations) {\n    var leaves = [_objectSpread$4({}, node)];\n\n    var _iterator23 = _createForOfIteratorHelper(_decorations),\n        _step23;\n\n    try {\n      for (_iterator23.s(); !(_step23 = _iterator23.n()).done;) {\n        var dec = _step23.value;\n\n        var rest = _objectWithoutProperties(dec, [\"anchor\", \"focus\"]);\n\n        var _Range$edges25 = Range.edges(dec),\n            _Range$edges26 = _slicedToArray(_Range$edges25, 2),\n            start = _Range$edges26[0],\n            end = _Range$edges26[1];\n\n        var next = [];\n        var o = 0;\n\n        var _iterator24 = _createForOfIteratorHelper(leaves),\n            _step24;\n\n        try {\n          for (_iterator24.s(); !(_step24 = _iterator24.n()).done;) {\n            var leaf = _step24.value;\n            var length = leaf.text.length;\n            var offset = o;\n            o += length; // If the range encompases the entire leaf, add the range.\n\n            if (start.offset <= offset && end.offset >= offset + length) {\n              Object.assign(leaf, rest);\n              next.push(leaf);\n              continue;\n            } // If the range starts after the leaf, or ends before it, continue.\n\n\n            if (start.offset > offset + length || end.offset < offset || end.offset === offset && offset !== 0) {\n              next.push(leaf);\n              continue;\n            } // Otherwise we need to split the leaf, at the start, end, or both,\n            // and add the range to the middle intersecting section. Do the end\n            // split first since we don't need to update the offset that way.\n\n\n            var middle = leaf;\n            var before = void 0;\n            var after = void 0;\n\n            if (end.offset < offset + length) {\n              var off = end.offset - offset;\n              after = _objectSpread$4({}, middle, {\n                text: middle.text.slice(off)\n              });\n              middle = _objectSpread$4({}, middle, {\n                text: middle.text.slice(0, off)\n              });\n            }\n\n            if (start.offset > offset) {\n              var _off = start.offset - offset;\n\n              before = _objectSpread$4({}, middle, {\n                text: middle.text.slice(0, _off)\n              });\n              middle = _objectSpread$4({}, middle, {\n                text: middle.text.slice(_off)\n              });\n            }\n\n            Object.assign(middle, rest);\n\n            if (before) {\n              next.push(before);\n            }\n\n            next.push(middle);\n\n            if (after) {\n              next.push(after);\n            }\n          }\n        } catch (err) {\n          _iterator24.e(err);\n        } finally {\n          _iterator24.f();\n        }\n\n        leaves = next;\n      }\n    } catch (err) {\n      _iterator23.e(err);\n    } finally {\n      _iterator23.f();\n    }\n\n    return leaves;\n  }\n};\n\nfunction ownKeys$5(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$5(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$5(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$5(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar GeneralTransforms = {\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform: function transform(editor, op) {\n    editor.children = createDraft(editor.children);\n    var selection = editor.selection && createDraft(editor.selection);\n\n    switch (op.type) {\n      case 'insert_node':\n        {\n          var path = op.path,\n              node = op.node;\n          var parent = Node.parent(editor, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 0, node);\n\n          if (selection) {\n            var _iterator25 = _createForOfIteratorHelper(Range.points(selection)),\n                _step25;\n\n            try {\n              for (_iterator25.s(); !(_step25 = _iterator25.n()).done;) {\n                var _step25$value = _slicedToArray(_step25.value, 2),\n                    point = _step25$value[0],\n                    key = _step25$value[1];\n\n                selection[key] = Point.transform(point, op);\n              }\n            } catch (err) {\n              _iterator25.e(err);\n            } finally {\n              _iterator25.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'insert_text':\n        {\n          var _path = op.path,\n              offset = op.offset,\n              text = op.text;\n\n          var _node = Node.leaf(editor, _path);\n\n          var before = _node.text.slice(0, offset);\n\n          var after = _node.text.slice(offset);\n\n          _node.text = before + text + after;\n\n          if (selection) {\n            var _iterator26 = _createForOfIteratorHelper(Range.points(selection)),\n                _step26;\n\n            try {\n              for (_iterator26.s(); !(_step26 = _iterator26.n()).done;) {\n                var _step26$value = _slicedToArray(_step26.value, 2),\n                    _point = _step26$value[0],\n                    _key = _step26$value[1];\n\n                selection[_key] = Point.transform(_point, op);\n              }\n            } catch (err) {\n              _iterator26.e(err);\n            } finally {\n              _iterator26.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'merge_node':\n        {\n          var _path2 = op.path;\n\n          var _node2 = Node.get(editor, _path2);\n\n          var prevPath = Path.previous(_path2);\n          var prev = Node.get(editor, prevPath);\n\n          var _parent = Node.parent(editor, _path2);\n\n          var _index = _path2[_path2.length - 1];\n\n          if (Text.isText(_node2) && Text.isText(prev)) {\n            prev.text += _node2.text;\n          } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n            var _prev$children2;\n\n            (_prev$children2 = prev.children).push.apply(_prev$children2, _toConsumableArray(_node2.children));\n          } else {\n            throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interaces: \").concat(_node2, \" \").concat(prev));\n          }\n\n          _parent.children.splice(_index, 1);\n\n          if (selection) {\n            var _iterator27 = _createForOfIteratorHelper(Range.points(selection)),\n                _step27;\n\n            try {\n              for (_iterator27.s(); !(_step27 = _iterator27.n()).done;) {\n                var _step27$value = _slicedToArray(_step27.value, 2),\n                    _point2 = _step27$value[0],\n                    _key2 = _step27$value[1];\n\n                selection[_key2] = Point.transform(_point2, op);\n              }\n            } catch (err) {\n              _iterator27.e(err);\n            } finally {\n              _iterator27.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'move_node':\n        {\n          var _path3 = op.path,\n              newPath = op.newPath;\n\n          if (Path.isAncestor(_path3, newPath)) {\n            throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n          }\n\n          var _node3 = Node.get(editor, _path3);\n\n          var _parent2 = Node.parent(editor, _path3);\n\n          var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n          // the same snapshot in time, there's a mismatch. After either\n          // removing the original position, the second step's path can be out\n          // of date. So instead of using the `op.newPath` directly, we\n          // transform `op.path` to ascertain what the `newPath` would be after\n          // the operation was applied.\n\n          _parent2.children.splice(_index2, 1);\n\n          var truePath = Path.transform(_path3, op);\n          var newParent = Node.get(editor, Path.parent(truePath));\n          var newIndex = truePath[truePath.length - 1];\n          newParent.children.splice(newIndex, 0, _node3);\n\n          if (selection) {\n            var _iterator28 = _createForOfIteratorHelper(Range.points(selection)),\n                _step28;\n\n            try {\n              for (_iterator28.s(); !(_step28 = _iterator28.n()).done;) {\n                var _step28$value = _slicedToArray(_step28.value, 2),\n                    _point3 = _step28$value[0],\n                    _key3 = _step28$value[1];\n\n                selection[_key3] = Point.transform(_point3, op);\n              }\n            } catch (err) {\n              _iterator28.e(err);\n            } finally {\n              _iterator28.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_node':\n        {\n          var _path4 = op.path;\n          var _index3 = _path4[_path4.length - 1];\n\n          var _parent3 = Node.parent(editor, _path4);\n\n          _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n          // node that was removed we need to update the range or remove it.\n\n\n          if (selection) {\n            var _iterator29 = _createForOfIteratorHelper(Range.points(selection)),\n                _step29;\n\n            try {\n              for (_iterator29.s(); !(_step29 = _iterator29.n()).done;) {\n                var _step29$value = _slicedToArray(_step29.value, 2),\n                    _point4 = _step29$value[0],\n                    _key4 = _step29$value[1];\n\n                var result = Point.transform(_point4, op);\n\n                if (selection != null && result != null) {\n                  selection[_key4] = result;\n                } else {\n                  var _prev = void 0;\n\n                  var next = void 0;\n\n                  var _iterator30 = _createForOfIteratorHelper(Node.texts(editor)),\n                      _step30;\n\n                  try {\n                    for (_iterator30.s(); !(_step30 = _iterator30.n()).done;) {\n                      var _step30$value = _slicedToArray(_step30.value, 2),\n                          n = _step30$value[0],\n                          p = _step30$value[1];\n\n                      if (Path.compare(p, _path4) === -1) {\n                        _prev = [n, p];\n                      } else {\n                        next = [n, p];\n                        break;\n                      }\n                    }\n                  } catch (err) {\n                    _iterator30.e(err);\n                  } finally {\n                    _iterator30.f();\n                  }\n\n                  if (_prev) {\n                    _point4.path = _prev[1];\n                    _point4.offset = _prev[0].text.length;\n                  } else if (next) {\n                    _point4.path = next[1];\n                    _point4.offset = 0;\n                  } else {\n                    selection = null;\n                  }\n                }\n              }\n            } catch (err) {\n              _iterator29.e(err);\n            } finally {\n              _iterator29.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'remove_text':\n        {\n          var _path5 = op.path,\n              _offset = op.offset,\n              _text = op.text;\n\n          var _node4 = Node.leaf(editor, _path5);\n\n          var _before = _node4.text.slice(0, _offset);\n\n          var _after = _node4.text.slice(_offset + _text.length);\n\n          _node4.text = _before + _after;\n\n          if (selection) {\n            var _iterator31 = _createForOfIteratorHelper(Range.points(selection)),\n                _step31;\n\n            try {\n              for (_iterator31.s(); !(_step31 = _iterator31.n()).done;) {\n                var _step31$value = _slicedToArray(_step31.value, 2),\n                    _point5 = _step31$value[0],\n                    _key5 = _step31$value[1];\n\n                selection[_key5] = Point.transform(_point5, op);\n              }\n            } catch (err) {\n              _iterator31.e(err);\n            } finally {\n              _iterator31.f();\n            }\n          }\n\n          break;\n        }\n\n      case 'set_node':\n        {\n          var _path6 = op.path,\n              newProperties = op.newProperties;\n\n          if (_path6.length === 0) {\n            throw new Error(\"Cannot set properties on the root node!\");\n          }\n\n          var _node5 = Node.get(editor, _path6);\n\n          for (var _key6 in newProperties) {\n            if (_key6 === 'children' || _key6 === 'text') {\n              throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n            }\n\n            var value = newProperties[_key6];\n\n            if (value == null) {\n              delete _node5[_key6];\n            } else {\n              _node5[_key6] = value;\n            }\n          }\n\n          break;\n        }\n\n      case 'set_selection':\n        {\n          var _newProperties = op.newProperties;\n\n          if (_newProperties == null) {\n            selection = _newProperties;\n          } else if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(JSON.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _newProperties;\n          } else {\n            Object.assign(selection, _newProperties);\n          }\n\n          break;\n        }\n\n      case 'split_node':\n        {\n          var _path7 = op.path,\n              position = op.position,\n              properties = op.properties;\n\n          if (_path7.length === 0) {\n            throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n          }\n\n          var _node6 = Node.get(editor, _path7);\n\n          var _parent4 = Node.parent(editor, _path7);\n\n          var _index4 = _path7[_path7.length - 1];\n          var newNode;\n\n          if (Text.isText(_node6)) {\n            var _before2 = _node6.text.slice(0, position);\n\n            var _after2 = _node6.text.slice(position);\n\n            _node6.text = _before2;\n            newNode = _objectSpread$5({}, _node6, {}, properties, {\n              text: _after2\n            });\n          } else {\n            var _before3 = _node6.children.slice(0, position);\n\n            var _after3 = _node6.children.slice(position);\n\n            _node6.children = _before3;\n            newNode = _objectSpread$5({}, _node6, {}, properties, {\n              children: _after3\n            });\n          }\n\n          _parent4.children.splice(_index4 + 1, 0, newNode);\n\n          if (selection) {\n            var _iterator32 = _createForOfIteratorHelper(Range.points(selection)),\n                _step32;\n\n            try {\n              for (_iterator32.s(); !(_step32 = _iterator32.n()).done;) {\n                var _step32$value = _slicedToArray(_step32.value, 2),\n                    _point6 = _step32$value[0],\n                    _key7 = _step32$value[1];\n\n                selection[_key7] = Point.transform(_point6, op);\n              }\n            } catch (err) {\n              _iterator32.e(err);\n            } finally {\n              _iterator32.f();\n            }\n          }\n\n          break;\n        }\n    }\n\n    editor.children = finishDraft(editor.children);\n\n    if (selection) {\n      editor.selection = isDraft(selection) ? finishDraft(selection) : selection;\n    } else {\n      editor.selection = null;\n    }\n  }\n};\n\nfunction ownKeys$6(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$6(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$6(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$6(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes: function insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging = options.hanging,\n          hanging = _options$hanging === void 0 ? false : _options$hanging,\n          _options$voids7 = options.voids,\n          voids = _options$voids7 === void 0 ? false : _options$voids7,\n          _options$mode5 = options.mode,\n          mode = _options$mode5 === void 0 ? 'lowest' : _options$mode5;\n      var at = options.at,\n          match = options.match,\n          select = options.select;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var _nodes = nodes,\n          _nodes2 = _slicedToArray(_nodes, 1),\n          node = _nodes2[0]; // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n\n        select = true;\n      }\n\n      if (select == null) {\n        select = false;\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges27 = Range.edges(at),\n              _Range$edges28 = _slicedToArray(_Range$edges27, 2),\n              end = _Range$edges28[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = function match(n) {\n              return Text.isText(n);\n            };\n          } else if (editor.isInline(node)) {\n            match = function match(n) {\n              return Text.isText(n) || Editor.isInline(editor, n);\n            };\n          } else {\n            match = function match(n) {\n              return Editor.isBlock(editor, n);\n            };\n          }\n        }\n\n        var _Editor$nodes7 = Editor.nodes(editor, {\n          at: at.path,\n          match: match,\n          mode: mode,\n          voids: voids\n        }),\n            _Editor$nodes8 = _slicedToArray(_Editor$nodes7, 1),\n            entry = _Editor$nodes8[0];\n\n        if (entry) {\n          var _entry = _slicedToArray(entry, 2),\n              _matchPath = _entry[1];\n\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at: at,\n            match: match,\n            mode: mode,\n            voids: voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (!voids && Editor[\"void\"](editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n\n      var _iterator33 = _createForOfIteratorHelper(nodes),\n          _step33;\n\n      try {\n        for (_iterator33.s(); !(_step33 = _iterator33.n()).done;) {\n          var _node = _step33.value;\n\n          var _path = parentPath.concat(index);\n\n          index++;\n          editor.apply({\n            type: 'insert_node',\n            path: _path,\n            node: _node\n          });\n        }\n      } catch (err) {\n        _iterator33.e(err);\n      } finally {\n        _iterator33.f();\n      }\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes: function liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$at7 = options.at,\n          at = _options$at7 === void 0 ? editor.selection : _options$at7,\n          _options$mode6 = options.mode,\n          mode = _options$mode6 === void 0 ? 'lowest' : _options$mode6,\n          _options$voids8 = options.voids,\n          voids = _options$voids8 === void 0 ? false : _options$voids8;\n      var match = options.match;\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(matches, function (_ref) {\n        var _ref9 = _slicedToArray(_ref, 2),\n            p = _ref9[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i = 0, _pathRefs = pathRefs; _i < _pathRefs.length; _i++) {\n        var pathRef = _pathRefs[_i];\n        var path = pathRef.unref();\n\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n\n        var _parentNodeEntry = _slicedToArray(parentNodeEntry, 2),\n            parent = _parentNodeEntry[0],\n            parentPath = _parentNodeEntry[1];\n\n        var index = path[path.length - 1];\n        var length = parent.children.length;\n\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids: voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids: voids\n          });\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids: voids\n          });\n        } else if (index === length - 1) {\n          var _toPath = Path.next(parentPath);\n\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids: voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n\n          var _toPath2 = Path.next(parentPath);\n\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids: voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids: voids\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes: function mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at8 = options.at,\n          at = _options$at8 === void 0 ? editor.selection : _options$at8;\n      var _options$hanging2 = options.hanging,\n          hanging = _options$hanging2 === void 0 ? false : _options$hanging2,\n          _options$voids9 = options.voids,\n          voids = _options$voids9 === void 0 ? false : _options$voids9,\n          _options$mode7 = options.mode,\n          mode = _options$mode7 === void 0 ? 'lowest' : _options$mode7;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var _Editor$parent5 = Editor.parent(editor, at),\n              _Editor$parent6 = _slicedToArray(_Editor$parent5, 1),\n              parent = _Editor$parent6[0];\n\n          match = function match(n) {\n            return parent.children.includes(n);\n          };\n        } else {\n          match = function match(n) {\n            return Editor.isBlock(editor, n);\n          };\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges29 = Range.edges(at),\n              _Range$edges30 = _slicedToArray(_Range$edges29, 2),\n              end = _Range$edges30[1];\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n\n      var _Editor$nodes9 = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      }),\n          _Editor$nodes10 = _slicedToArray(_Editor$nodes9, 1),\n          current = _Editor$nodes10[0];\n\n      var prev = Editor.previous(editor, {\n        at: at,\n        match: match,\n        voids: voids,\n        mode: mode\n      });\n\n      if (!current || !prev) {\n        return;\n      }\n\n      var _current = _slicedToArray(current, 2),\n          node = _current[0],\n          path = _current[1];\n\n      var _prev3 = _slicedToArray(prev, 2),\n          prevNode = _prev3[0],\n          prevPath = _prev3[1];\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), function (_ref2) {\n        var _ref10 = _slicedToArray(_ref2, 1),\n            n = _ref10[0];\n\n        return n;\n      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: function match(n) {\n          return levels.includes(n) && Element.isElement(n) && n.children.length === 1;\n        }\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        var rest = _objectWithoutProperties(node, [\"text\"]);\n\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        var rest = _objectWithoutProperties(node, [\"children\"]);\n\n        position = prevNode.children.length;\n        properties = rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(JSON.stringify(node), \" \").concat(JSON.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids: voids\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids: voids\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '') {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids: voids\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position: position,\n          target: null,\n          properties: properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes: function moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, function () {\n      var to = options.to,\n          _options$at9 = options.at,\n          at = _options$at9 === void 0 ? editor.selection : _options$at9,\n          _options$mode8 = options.mode,\n          mode = _options$mode8 === void 0 ? 'lowest' : _options$mode8,\n          _options$voids10 = options.voids,\n          voids = _options$voids10 === void 0 ? false : _options$voids10;\n      var match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(targets, function (_ref3) {\n        var _ref11 = _slicedToArray(_ref3, 2),\n            p = _ref11[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i2 = 0, _pathRefs2 = pathRefs; _i2 < _pathRefs2.length; _i2++) {\n        var pathRef = _pathRefs2[_i2];\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n\n        if (path.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path: path,\n            newPath: newPath\n          });\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes: function removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging3 = options.hanging,\n          hanging = _options$hanging3 === void 0 ? false : _options$hanging3,\n          _options$voids11 = options.voids,\n          voids = _options$voids11 === void 0 ? false : _options$voids11,\n          _options$mode9 = options.mode,\n          mode = _options$mode9 === void 0 ? 'lowest' : _options$mode9;\n      var _options$at10 = options.at,\n          at = _options$at10 === void 0 ? editor.selection : _options$at10,\n          match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      var depths = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(depths, function (_ref4) {\n        var _ref12 = _slicedToArray(_ref4, 2),\n            p = _ref12[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var _i3 = 0, _pathRefs3 = pathRefs; _i3 < _pathRefs3.length; _i3++) {\n        var pathRef = _pathRefs3[_i3];\n        var path = pathRef.unref();\n\n        if (path) {\n          var _Editor$node = Editor.node(editor, path),\n              _Editor$node2 = _slicedToArray(_Editor$node, 1),\n              node = _Editor$node2[0];\n\n          editor.apply({\n            type: 'remove_node',\n            path: path,\n            node: node\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\n  setNodes: function setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var match = options.match,\n          _options$at11 = options.at,\n          at = _options$at11 === void 0 ? editor.selection : _options$at11;\n      var _options$hanging4 = options.hanging,\n          hanging = _options$hanging4 === void 0 ? false : _options$hanging4,\n          _options$mode10 = options.mode,\n          mode = _options$mode10 === void 0 ? 'lowest' : _options$mode10,\n          _options$split = options.split,\n          split = _options$split === void 0 ? false : _options$split,\n          _options$voids12 = options.voids,\n          voids = _options$voids12 === void 0 ? false : _options$voids12;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (split && Range.isRange(at)) {\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n\n        var _Range$edges31 = Range.edges(at),\n            _Range$edges32 = _slicedToArray(_Range$edges31, 2),\n            start = _Range$edges32[0],\n            end = _Range$edges32[1];\n\n        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n        Transforms.splitNodes(editor, {\n          at: end,\n          match: match,\n          mode: splitMode,\n          voids: voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match: match,\n          mode: splitMode,\n          voids: voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var _iterator34 = _createForOfIteratorHelper(Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      })),\n          _step34;\n\n      try {\n        for (_iterator34.s(); !(_step34 = _iterator34.n()).done;) {\n          var _step34$value = _slicedToArray(_step34.value, 2),\n              node = _step34$value[0],\n              path = _step34$value[1];\n\n          var properties = {};\n          var newProperties = {}; // You can't set properties on the editor node.\n\n          if (path.length === 0) {\n            continue;\n          }\n\n          for (var k in props) {\n            if (k === 'children' || k === 'text') {\n              continue;\n            }\n\n            if (props[k] !== node[k]) {\n              properties[k] = node[k];\n              newProperties[k] = props[k];\n            }\n          }\n\n          if (Object.keys(newProperties).length !== 0) {\n            editor.apply({\n              type: 'set_node',\n              path: path,\n              properties: properties,\n              newProperties: newProperties\n            });\n          }\n        }\n      } catch (err) {\n        _iterator34.e(err);\n      } finally {\n        _iterator34.f();\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes: function splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode11 = options.mode,\n          mode = _options$mode11 === void 0 ? 'lowest' : _options$mode11,\n          _options$voids13 = options.voids,\n          voids = _options$voids13 === void 0 ? false : _options$voids13;\n      var match = options.match,\n          _options$at12 = options.at,\n          at = _options$at12 === void 0 ? editor.selection : _options$at12,\n          _options$height = options.height,\n          height = _options$height === void 0 ? 0 : _options$height,\n          _options$always = options.always,\n          always = _options$always === void 0 ? false : _options$always;\n\n      if (match == null) {\n        match = function match(n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n\n        var _Editor$parent7 = Editor.parent(editor, path),\n            _Editor$parent8 = _slicedToArray(_Editor$parent7, 1),\n            parent = _Editor$parent8[0];\n\n        match = function match(n) {\n          return n === parent;\n        };\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n\n      var _Editor$nodes11 = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      }),\n          _Editor$nodes12 = _slicedToArray(_Editor$nodes11, 1),\n          highest = _Editor$nodes12[0];\n\n      if (!highest) {\n        return;\n      }\n\n      var voidMatch = Editor[\"void\"](editor, {\n        at: at,\n        mode: 'highest'\n      });\n      var nudge = 0;\n\n      if (!voids && voidMatch) {\n        var _voidMatch = _slicedToArray(voidMatch, 2),\n            voidNode = _voidMatch[0],\n            voidPath = _voidMatch[1];\n\n        if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n          var after = Editor.after(editor, voidPath);\n\n          if (!after) {\n            var text = {\n              text: ''\n            };\n            var afterPath = Path.next(voidPath);\n            Transforms.insertNodes(editor, text, {\n              at: afterPath,\n              voids: voids\n            });\n            after = Editor.point(editor, afterPath);\n          }\n\n          at = after;\n          always = true;\n        }\n\n        var siblingHeight = at.path.length - voidPath.length;\n        height = siblingHeight + 1;\n        always = true;\n      }\n\n      var afterRef = Editor.pointRef(editor, at);\n      var depth = at.path.length - height;\n\n      var _highest = _slicedToArray(highest, 2),\n          highestPath = _highest[1];\n\n      var lowestPath = at.path.slice(0, depth);\n      var position = height === 0 ? at.offset : at.path[depth] + nudge;\n      var target = null;\n\n      var _iterator35 = _createForOfIteratorHelper(Editor.levels(editor, {\n        at: lowestPath,\n        reverse: true,\n        voids: voids\n      })),\n          _step35;\n\n      try {\n        for (_iterator35.s(); !(_step35 = _iterator35.n()).done;) {\n          var _step35$value = _slicedToArray(_step35.value, 2),\n              node = _step35$value[0],\n              _path2 = _step35$value[1];\n\n          var split = false;\n\n          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {\n            break;\n          }\n\n          var _point = beforeRef.current;\n          var isEnd = Editor.isEnd(editor, _point, _path2);\n\n          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n            split = true;\n\n            var properties = _objectWithoutProperties(node, [\"text\", \"children\"]);\n\n            editor.apply({\n              type: 'split_node',\n              path: _path2,\n              position: position,\n              target: target,\n              properties: properties\n            });\n          }\n\n          target = position;\n          position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n        }\n      } catch (err) {\n        _iterator35.e(err);\n      } finally {\n        _iterator35.f();\n      }\n\n      if (options.at == null) {\n        var _point2 = afterRef.current || Editor.end(editor, []);\n\n        Transforms.select(editor, _point2);\n      }\n\n      beforeRef.unref();\n      afterRef.unref();\n    });\n  },\n\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\n  unsetNodes: function unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n\n    var obj = {};\n\n    var _iterator36 = _createForOfIteratorHelper(props),\n        _step36;\n\n    try {\n      for (_iterator36.s(); !(_step36 = _iterator36.n()).done;) {\n        var key = _step36.value;\n        obj[key] = null;\n      }\n    } catch (err) {\n      _iterator36.e(err);\n    } finally {\n      _iterator36.f();\n    }\n\n    Transforms.setNodes(editor, obj, options);\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes: function unwrapNodes(editor, options) {\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode12 = options.mode,\n          mode = _options$mode12 === void 0 ? 'lowest' : _options$mode12,\n          _options$split2 = options.split,\n          split = _options$split2 === void 0 ? false : _options$split2,\n          _options$voids14 = options.voids,\n          voids = _options$voids14 === void 0 ? false : _options$voids14;\n      var _options$at13 = options.at,\n          at = _options$at13 === void 0 ? editor.selection : _options$at13,\n          match = options.match;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : function (n) {\n          return Editor.isBlock(editor, n);\n        };\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at: at,\n        match: match,\n        mode: mode,\n        voids: voids\n      });\n      var pathRefs = Array.from(matches, function (_ref5) {\n        var _ref13 = _slicedToArray(_ref5, 2),\n            p = _ref13[1];\n\n        return Editor.pathRef(editor, p);\n      });\n\n      var _loop = function _loop(pathRef) {\n        var path = pathRef.unref();\n\n        var _Editor$node3 = Editor.node(editor, path),\n            _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n            node = _Editor$node4[0];\n\n        var range = Editor.range(editor, path);\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current, range);\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: function match(n) {\n            return node.children.includes(n);\n          },\n          voids: voids\n        });\n      };\n\n      for (var _i4 = 0, _pathRefs4 = pathRefs; _i4 < _pathRefs4.length; _i4++) {\n        var pathRef = _pathRefs4[_i4];\n\n        _loop(pathRef);\n      }\n\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes: function wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$mode13 = options.mode,\n          mode = _options$mode13 === void 0 ? 'lowest' : _options$mode13,\n          _options$split3 = options.split,\n          split = _options$split3 === void 0 ? false : _options$split3,\n          _options$voids15 = options.voids,\n          voids = _options$voids15 === void 0 ? false : _options$voids15;\n      var match = options.match,\n          _options$at14 = options.at,\n          at = _options$at14 === void 0 ? editor.selection : _options$at14;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at);\n        } else if (editor.isInline(element)) {\n          match = function match(n) {\n            return Editor.isInline(editor, n) || Text.isText(n);\n          };\n        } else {\n          match = function match(n) {\n            return Editor.isBlock(editor, n);\n          };\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        var _Range$edges33 = Range.edges(at),\n            _Range$edges34 = _slicedToArray(_Range$edges33, 2),\n            start = _Range$edges34[0],\n            end = _Range$edges34[1];\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Transforms.splitNodes(editor, {\n          at: end,\n          match: match,\n          voids: voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match: match,\n          voids: voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var roots = Array.from(Editor.nodes(editor, {\n        at: at,\n        match: editor.isInline(element) ? function (n) {\n          return Editor.isBlock(editor, n);\n        } : function (n) {\n          return Editor.isEditor(n);\n        },\n        mode: 'lowest',\n        voids: voids\n      }));\n\n      for (var _i5 = 0, _roots = roots; _i5 < _roots.length; _i5++) {\n        var _roots$_i = _slicedToArray(_roots[_i5], 2),\n            rootPath = _roots$_i[1];\n\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n        if (!a) {\n          continue;\n        }\n\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match: match,\n          mode: mode,\n          voids: voids\n        }));\n\n        if (matches.length > 0) {\n          (function () {\n            var _matches = _slicedToArray(matches, 1),\n                first = _matches[0];\n\n            var last = matches[matches.length - 1];\n\n            var _first = _slicedToArray(first, 2),\n                firstPath = _first[1];\n\n            var _last = _slicedToArray(last, 2),\n                lastPath = _last[1];\n\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n\n            var _commonNodeEntry = _slicedToArray(commonNodeEntry, 1),\n                commonNode = _commonNodeEntry[0];\n\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n            var wrapper = _objectSpread$6({}, element, {\n              children: []\n            });\n\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids: voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: function match(n) {\n                return commonNode.children.includes(n);\n              },\n              to: wrapperPath.concat(0),\n              voids: voids\n            });\n          })();\n        }\n      }\n    });\n  }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\nvar deleteRange = function deleteRange(editor, range) {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var _Range$edges35 = Range.edges(range),\n        _Range$edges36 = _slicedToArray(_Range$edges35, 2),\n        end = _Range$edges36[1];\n\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms[\"delete\"](editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar matchPath = function matchPath(editor, path) {\n  var _Editor$node5 = Editor.node(editor, path),\n      _Editor$node6 = _slicedToArray(_Editor$node5, 1),\n      node = _Editor$node6[0];\n\n  return function (n) {\n    return n === node;\n  };\n};\n\nfunction ownKeys$7(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$7(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$7(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$7(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse: function collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$edge2 = options.edge,\n        edge = _options$edge2 === void 0 ? 'anchor' : _options$edge2;\n    var selection = editor.selection;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var _Range$edges37 = Range.edges(selection),\n          _Range$edges38 = _slicedToArray(_Range$edges37, 1),\n          start = _Range$edges38[0];\n\n      Transforms.select(editor, start);\n    } else if (edge === 'end') {\n      var _Range$edges39 = Range.edges(selection),\n          _Range$edges40 = _slicedToArray(_Range$edges39, 2),\n          end = _Range$edges40[1];\n\n      Transforms.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect: function deselect(editor) {\n    var selection = editor.selection;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move: function move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var selection = editor.selection;\n    var _options$distance3 = options.distance,\n        distance = _options$distance3 === void 0 ? 1 : _options$distance3,\n        _options$unit4 = options.unit,\n        unit = _options$unit4 === void 0 ? 'character' : _options$unit4,\n        _options$reverse9 = options.reverse,\n        reverse = _options$reverse9 === void 0 ? false : _options$reverse9;\n    var _options$edge3 = options.edge,\n        edge = _options$edge3 === void 0 ? null : _options$edge3;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var opts = {\n      distance: distance,\n      unit: unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Transforms.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select: function select(editor, target) {\n    var selection = editor.selection;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(JSON.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint: function setPoint(editor, props, options) {\n    var selection = editor.selection;\n    var _options$edge4 = options.edge,\n        edge = _options$edge4 === void 0 ? 'both' : _options$edge4;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var anchor = selection.anchor,\n        focus = selection.focus;\n    var point = edge === 'anchor' ? anchor : focus;\n    Transforms.setSelection(editor, _defineProperty2({}, edge === 'anchor' ? 'anchor' : 'focus', _objectSpread$7({}, point, {}, props)));\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection: function setSelection(editor, props) {\n    var selection = editor.selection;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n};\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  \"delete\": function _delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$reverse10 = options.reverse,\n          reverse = _options$reverse10 === void 0 ? false : _options$reverse10,\n          _options$unit5 = options.unit,\n          unit = _options$unit5 === void 0 ? 'character' : _options$unit5,\n          _options$distance4 = options.distance,\n          distance = _options$distance4 === void 0 ? 1 : _options$distance4,\n          _options$voids16 = options.voids,\n          voids = _options$voids16 === void 0 ? false : _options$voids16;\n      var _options$at15 = options.at,\n          at = _options$at15 === void 0 ? editor.selection : _options$at15,\n          _options$hanging5 = options.hanging,\n          hanging = _options$hanging5 === void 0 ? false : _options$hanging5;\n\n      if (!at) {\n        return;\n      }\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor[\"void\"](editor, {\n          at: at,\n          mode: 'highest'\n        });\n\n        if (!voids && furthestVoid) {\n          var _furthestVoid = _slicedToArray(furthestVoid, 2),\n              voidPath = _furthestVoid[1];\n\n          at = voidPath;\n        } else {\n          var opts = {\n            unit: unit,\n            distance: distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at: at,\n          voids: voids\n        });\n        return;\n      }\n\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        at = Editor.unhangRange(editor, at, {\n          voids: voids\n        });\n      }\n\n      var _Range$edges41 = Range.edges(at),\n          _Range$edges42 = _slicedToArray(_Range$edges41, 2),\n          start = _Range$edges42[0],\n          end = _Range$edges42[1];\n\n      var startBlock = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        at: start,\n        voids: voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        at: end,\n        voids: voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = voids ? null : Editor[\"void\"](editor, {\n        at: start,\n        mode: 'highest'\n      });\n      var endVoid = voids ? null : Editor[\"void\"](editor, {\n        at: end,\n        mode: 'highest'\n      }); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var before = Editor.before(editor, start);\n\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var after = Editor.after(editor, end);\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = [];\n      var lastPath;\n\n      var _iterator37 = _createForOfIteratorHelper(Editor.nodes(editor, {\n        at: at,\n        voids: voids\n      })),\n          _step37;\n\n      try {\n        for (_iterator37.s(); !(_step37 = _iterator37.n()).done;) {\n          var entry = _step37.value;\n\n          var _entry2 = _slicedToArray(entry, 2),\n              node = _entry2[0],\n              path = _entry2[1];\n\n          if (lastPath && Path.compare(path, lastPath) === 0) {\n            continue;\n          }\n\n          if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n            matches.push(entry);\n            lastPath = path;\n          }\n        }\n      } catch (err) {\n        _iterator37.e(err);\n      } finally {\n        _iterator37.f();\n      }\n\n      var pathRefs = Array.from(matches, function (_ref) {\n        var _ref14 = _slicedToArray(_ref, 2),\n            p = _ref14[1];\n\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n\n        var _Editor$leaf3 = Editor.leaf(editor, _point),\n            _Editor$leaf4 = _slicedToArray(_Editor$leaf3, 1),\n            _node = _Editor$leaf4[0];\n\n        var _path = _point.path;\n        var _start = start,\n            offset = _start.offset;\n\n        var text = _node.text.slice(offset);\n\n        editor.apply({\n          type: 'remove_text',\n          path: _path,\n          offset: offset,\n          text: text\n        });\n      }\n\n      for (var _i6 = 0, _pathRefs5 = pathRefs; _i6 < _pathRefs5.length; _i6++) {\n        var pathRef = _pathRefs5[_i6];\n\n        var _path2 = pathRef.unref();\n\n        Transforms.removeNodes(editor, {\n          at: _path2,\n          voids: voids\n        });\n      }\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n\n        var _Editor$leaf5 = Editor.leaf(editor, _point2),\n            _Editor$leaf6 = _slicedToArray(_Editor$leaf5, 1),\n            _node2 = _Editor$leaf6[0];\n\n        var _path3 = _point2.path;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node2.text.slice(_offset, end.offset);\n\n        editor.apply({\n          type: 'remove_text',\n          path: _path3,\n          offset: _offset,\n          text: _text\n        });\n      }\n\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids: voids\n        });\n      }\n\n      var point = endRef.unref() || startRef.unref();\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment: function insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$hanging6 = options.hanging,\n          hanging = _options$hanging6 === void 0 ? false : _options$hanging6,\n          _options$voids17 = options.voids,\n          voids = _options$voids17 === void 0 ? false : _options$voids17;\n      var _options$at16 = options.at,\n          at = _options$at16 === void 0 ? editor.selection : _options$at16;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var _Range$edges43 = Range.edges(at),\n              _Range$edges44 = _slicedToArray(_Range$edges43, 2),\n              end = _Range$edges44[1];\n\n          if (!voids && Editor[\"void\"](editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (!voids && Editor[\"void\"](editor, {\n        at: at\n      })) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.above(editor, {\n        at: at,\n        match: function match(n) {\n          return Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (inlineElementMatch) {\n        var _inlineElementMatch = _slicedToArray(inlineElementMatch, 2),\n            _inlinePath = _inlineElementMatch[1];\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.above(editor, {\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        at: at,\n        voids: voids\n      });\n\n      var _blockMatch = _slicedToArray(blockMatch, 2),\n          blockPath = _blockMatch[1];\n\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n\n      var _Node$first5 = Node.first({\n        children: fragment\n      }, []),\n          _Node$first6 = _slicedToArray(_Node$first5, 2),\n          firstPath = _Node$first6[1];\n\n      var _Node$last5 = Node.last({\n        children: fragment\n      }, []),\n          _Node$last6 = _slicedToArray(_Node$last5, 2),\n          lastPath = _Node$last6[1];\n\n      var matches = [];\n\n      var matcher = function matcher(_ref2) {\n        var _ref15 = _slicedToArray(_ref2, 2),\n            n = _ref15[0],\n            p = _ref15[1];\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      var _iterator38 = _createForOfIteratorHelper(Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })),\n          _step38;\n\n      try {\n        for (_iterator38.s(); !(_step38 = _iterator38.n()).done;) {\n          var entry = _step38.value;\n\n          if (entry[1].length > 0 && matcher(entry)) {\n            matches.push(entry);\n          }\n        }\n      } catch (err) {\n        _iterator38.e(err);\n      } finally {\n        _iterator38.f();\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var _i7 = 0, _matches2 = matches; _i7 < _matches2.length; _i7++) {\n        var _matches2$_i = _slicedToArray(_matches2[_i7], 1),\n            node = _matches2$_i[0];\n\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var _Editor$nodes13 = Editor.nodes(editor, {\n        at: at,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      }),\n          _Editor$nodes14 = _slicedToArray(_Editor$nodes13, 1),\n          inlineMatch = _Editor$nodes14[0];\n\n      var _inlineMatch = _slicedToArray(inlineMatch, 2),\n          inlinePath = _inlineMatch[1];\n\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at: at,\n        match: function match(n) {\n          return hasBlocks ? Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: hasBlocks ? 'lowest' : 'highest',\n        voids: voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: function match(n) {\n          return Editor.isBlock(editor, n);\n        },\n        mode: 'lowest',\n        voids: voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: function match(n) {\n          return Text.isText(n) || Editor.isInline(editor, n);\n        },\n        mode: 'highest',\n        voids: voids\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0) {\n          path = Path.previous(middleRef.current);\n        } else {\n          path = Path.previous(startRef.current);\n        }\n\n        var _end = Editor.end(editor, path);\n\n        Transforms.select(editor, _end);\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText: function insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, function () {\n      var _options$voids18 = options.voids,\n          voids = _options$voids18 === void 0 ? false : _options$voids18;\n      var _options$at17 = options.at,\n          at = _options$at17 === void 0 ? editor.selection : _options$at17;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n\n          if (!voids && Editor[\"void\"](editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms[\"delete\"](editor, {\n            at: at,\n            voids: voids\n          });\n          at = pointRef.unref();\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor[\"void\"](editor, {\n        at: at\n      })) {\n        return;\n      }\n\n      var _at = at,\n          path = _at.path,\n          offset = _at.offset;\n      editor.apply({\n        type: 'insert_text',\n        path: path,\n        offset: offset,\n        text: text\n      });\n    });\n  }\n};\n\nfunction ownKeys$8(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$8(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$8(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$8(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nvar Transforms = _objectSpread$8({}, GeneralTransforms, {}, NodeTransforms, {}, SelectionTransforms, {}, TextTransforms);\n\nfunction ownKeys$9(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$9(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys$9(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys$9(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\n\nvar createEditor = function createEditor() {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: function isInline() {\n      return false;\n    },\n    isVoid: function isVoid() {\n      return false;\n    },\n    onChange: function onChange() {},\n    apply: function apply(op) {\n      var _iterator39 = _createForOfIteratorHelper(Editor.pathRefs(editor)),\n          _step39;\n\n      try {\n        for (_iterator39.s(); !(_step39 = _iterator39.n()).done;) {\n          var ref = _step39.value;\n          PathRef.transform(ref, op);\n        }\n      } catch (err) {\n        _iterator39.e(err);\n      } finally {\n        _iterator39.f();\n      }\n\n      var _iterator40 = _createForOfIteratorHelper(Editor.pointRefs(editor)),\n          _step40;\n\n      try {\n        for (_iterator40.s(); !(_step40 = _iterator40.n()).done;) {\n          var _ref = _step40.value;\n          PointRef.transform(_ref, op);\n        }\n      } catch (err) {\n        _iterator40.e(err);\n      } finally {\n        _iterator40.f();\n      }\n\n      var _iterator41 = _createForOfIteratorHelper(Editor.rangeRefs(editor)),\n          _step41;\n\n      try {\n        for (_iterator41.s(); !(_step41 = _iterator41.n()).done;) {\n          var _ref2 = _step41.value;\n          RangeRef.transform(_ref2, op);\n        }\n      } catch (err) {\n        _iterator41.e(err);\n      } finally {\n        _iterator41.f();\n      }\n\n      var set = new Set();\n      var dirtyPaths = [];\n\n      var add = function add(path) {\n        if (path) {\n          var key = path.join(',');\n\n          if (!set.has(key)) {\n            set.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var newDirtyPaths = getDirtyPaths(op);\n\n      var _iterator42 = _createForOfIteratorHelper(oldDirtyPaths),\n          _step42;\n\n      try {\n        for (_iterator42.s(); !(_step42 = _iterator42.n()).done;) {\n          var path = _step42.value;\n          var newPath = Path.transform(path, op);\n          add(newPath);\n        }\n      } catch (err) {\n        _iterator42.e(err);\n      } finally {\n        _iterator42.f();\n      }\n\n      var _iterator43 = _createForOfIteratorHelper(newDirtyPaths),\n          _step43;\n\n      try {\n        for (_iterator43.s(); !(_step43 = _iterator43.n()).done;) {\n          var _path = _step43.value;\n          add(_path);\n        }\n      } catch (err) {\n        _iterator43.e(err);\n      } finally {\n        _iterator43.f();\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      Editor.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor); // Clear any formats applied to the cursor if the selection changes.\n\n      if (op.type === 'set_selection') {\n        editor.marks = null;\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(function () {\n          FLUSHING.set(editor, false);\n          editor.onChange();\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: function addMark(key, value) {\n      var selection = editor.selection;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(editor, _defineProperty2({}, key, value), {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {}, _defineProperty2({}, key, value));\n\n          editor.marks = marks;\n          editor.onChange();\n        }\n      }\n    },\n    deleteBackward: function deleteBackward(unit) {\n      var selection = editor.selection;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms[\"delete\"](editor, {\n          unit: unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: function deleteForward(unit) {\n      var selection = editor.selection;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms[\"delete\"](editor, {\n          unit: unit\n        });\n      }\n    },\n    deleteFragment: function deleteFragment() {\n      var selection = editor.selection;\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms[\"delete\"](editor);\n      }\n    },\n    getFragment: function getFragment() {\n      var selection = editor.selection;\n\n      if (selection && Range.isExpanded(selection)) {\n        return Node.fragment(editor, selection);\n      }\n\n      return [];\n    },\n    insertBreak: function insertBreak() {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: function insertFragment(fragment) {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: function insertNode(node) {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: function insertText(text) {\n      var selection = editor.selection,\n          marks = editor.marks;\n\n      if (selection) {\n        // If the cursor is at the end of an inline, move it outside of\n        // the inline before inserting\n        if (Range.isCollapsed(selection)) {\n          var inline = Editor.above(editor, {\n            match: function match(n) {\n              return Editor.isInline(editor, n);\n            },\n            mode: 'highest'\n          });\n\n          if (inline) {\n            var _inline = _slicedToArray(inline, 2),\n                inlinePath = _inline[1];\n\n            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {\n              var point = Editor.after(editor, inlinePath);\n              Transforms.setSelection(editor, {\n                anchor: point,\n                focus: point\n              });\n            }\n          }\n        }\n\n        if (marks) {\n          var node = _objectSpread$9({\n            text: text\n          }, marks);\n\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text);\n        }\n\n        editor.marks = null;\n      }\n    },\n    normalizeNode: function normalizeNode(entry) {\n      var _entry3 = _slicedToArray(entry, 2),\n          node = _entry3[0],\n          path = _entry3[1]; // There are no core normalizations for text nodes.\n\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: ''\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var _child = node.children[i];\n        var prev = node.children[i - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true\n              });\n              n++;\n            } else if (isLast) {\n              var _newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1),\n                voids: true\n              });\n              n++;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true\n              });\n              n--;\n            } else if (isLast && _child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: function removeMark(key) {\n      var selection = editor.selection;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n\n          delete marks[key];\n          editor.marks = marks;\n          editor.onChange();\n        }\n      }\n    }\n  };\n  return editor;\n};\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\n\n\nvar getDirtyPaths = function getDirtyPaths(op) {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var path = op.path;\n        return Path.levels(path);\n      }\n\n    case 'insert_node':\n      {\n        var node = op.node,\n            _path2 = op.path;\n        var levels = Path.levels(_path2);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), function (_ref3) {\n          var _ref16 = _slicedToArray(_ref3, 2),\n              p = _ref16[1];\n\n          return _path2.concat(p);\n        });\n        return [].concat(_toConsumableArray(levels), _toConsumableArray(descendants));\n      }\n\n    case 'merge_node':\n      {\n        var _path3 = op.path;\n        var ancestors = Path.ancestors(_path3);\n        var previousPath = Path.previous(_path3);\n        return [].concat(_toConsumableArray(ancestors), [previousPath]);\n      }\n\n    case 'move_node':\n      {\n        var _path4 = op.path,\n            newPath = op.newPath;\n\n        if (Path.equals(_path4, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = [];\n        var newAncestors = [];\n\n        var _iterator44 = _createForOfIteratorHelper(Path.ancestors(_path4)),\n            _step44;\n\n        try {\n          for (_iterator44.s(); !(_step44 = _iterator44.n()).done;) {\n            var ancestor = _step44.value;\n            var p = Path.transform(ancestor, op);\n            oldAncestors.push(p);\n          }\n        } catch (err) {\n          _iterator44.e(err);\n        } finally {\n          _iterator44.f();\n        }\n\n        var _iterator45 = _createForOfIteratorHelper(Path.ancestors(newPath)),\n            _step45;\n\n        try {\n          for (_iterator45.s(); !(_step45 = _iterator45.n()).done;) {\n            var _ancestor = _step45.value;\n\n            var _p = Path.transform(_ancestor, op);\n\n            newAncestors.push(_p);\n          }\n        } catch (err) {\n          _iterator45.e(err);\n        } finally {\n          _iterator45.f();\n        }\n\n        return [].concat(oldAncestors, newAncestors);\n      }\n\n    case 'remove_node':\n      {\n        var _path5 = op.path;\n\n        var _ancestors = Path.ancestors(_path5);\n\n        return _toConsumableArray(_ancestors);\n      }\n\n    case 'split_node':\n      {\n        var _path6 = op.path;\n\n        var _levels = Path.levels(_path6);\n\n        var nextPath = Path.next(_path6);\n        return [].concat(_toConsumableArray(_levels), [nextPath]);\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nexport { Editor, Element, Location, Node, Operation, Path, PathRef, Point, PointRef, Range, RangeRef, Span, Text, Transforms, createEditor };"],"sourceRoot":""}